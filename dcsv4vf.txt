/*
Kaien's drone control system V4
?id=1406061291

last update:
v5.0.0 20190507
-----------------
vf walk mode

...

custom data sample for son ship:

CockpitNameTag=R_FORWARD
DCSLCDNameTag=DCS_LCD
fighterFcsName=Programmable block fcs
LCDNameTag=Text panel fcs
flyByDistance=0
upMode=true
flyByOffsetDirection=LEFT
flyByForwardDistance=250
flyByUpDistance=0
dockingForward=FORWARD
dockingUp=UP
dockingLeftDistance=0
dockingUpDistance=-33.5
dockingForwardDistance=61.5
dockingApproach=DOWN
dockingApproachDistance=40
dockingApproachDistanceLeft=0
dockingApproachDistanceUp=-53.5
dockingApproachDistanceForward=61.5
soundBlockNameTag=Sound Block fcs
shipLength=30
commandAllTic = 100
commandWaitTic = 0
limitInnerRotor=true
ScanRange=3000

custom data sample for mother ship

CockpitNameTag=Flight Seat 3
DCSLCDNameTag=DCS_LCD
fighterFcsName=Programmable block fcsoc
LCDNameTag=LCD Panel fcs
homingTurretName=R_FORWARD_OC
useTurretAsAimer=true
ScanRange=15000
liFcsSearchGroupName=Li-fcs-search-G
liFcsLockGroupName=Li-fcs-lock-G
macAV=0.005
isBase=true
maxTargetCount=1
ScanRange=3000

son ship commands

RPW
RPP
RPD
 : w = wingman, p = predock, d = docked

mother ship commands

FLYBYON
  :take off
DOCKINGON
  :landing
ATTACKON
  :attack enemy locked
ATTACKOFF
  :withdraw
WEAPON1
  :switch to gatlin guns
WEAPON2
  :switch to rocket launcher
*/


string CockpitNameTag = "Cockpit";
string HeadNameTag = "VF_HEAD";
string LCDNameTag = "FCS_LCD";
string DCSLCDNameTag = "DCS_LCD";
string GyroscopesNameTag = "";
string soundBlockNameTag = "FCSFoundSound";
string homingTurretName = "R_FORWARD_OC";
string gcTargetPanelName = "LCD Panel GC Target";
double ScanRange = 2000;
string fighterFcsName = "Programmable block fcs";

bool useTurretAsAimer = false;
string liFcsSearchGroupName = "Li-fcs-search-G";
string liFcsLockGroupName = "Li-fcs-lock-G";
int AimOnConfig = 1;
string rulerProjectorName = "Projector Ruler";
double shipWidth = 100;
double shipHeight = 40;
double shipLength = 180;
int flyByAttackRoundTime = 20000;

bool rulerOn = false;

Vector3D flyByAimPosition = new Vector3D(0,0,0);
Vector3D flyByAttackPosition = new Vector3D(0,0,0);
Vector3D shipPosition = new Vector3D(0,0,0);
Vector3D targetPosition = new Vector3D(0,0,0);
Vector3D shipSpeed = new Vector3D(0,0,0);
Vector3D flyByAimSpeed = new Vector3D(0,0,0);
bool needFlyByAim = false;
List<IMyTerminalBlock> liFcsSearchList = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> liFcsLockList = new List<IMyTerminalBlock>();
IMyTextPanel gcTargetPanel = null;
List<IMyTextPanel> gcTargetPanelList = new List<IMyTextPanel>();
int maxTargetCount = 1;
IMyTerminalBlock rulerProjector = null;
Vector3D naturalGravity;
double naturalGravityLength;
Vector3D holdPosition;
bool isHold = false;
bool isDown = false;
bool isME = false;
bool isLaunch = false;
bool isBase = false;
bool motherSignalRotation = false;
bool isTurning = false;
bool isBig = false;
bool dampenersOn = true;
double droneAttackRange = 0;
bool isPrinted = false;
bool isPtdTurnOn = false;
long ptdSeparatedStart = 0;
bool limitInnerRotor = true;
bool isAeroDynamic=false;
float angleWhenDown=0;
int aeroSpeedLevel=0;
int sl_fs = 0;
int sl_bs = 0;
void aeroSLp(bool a){

if (a) {
// acc
if (sl_fs == 0) {
sl_fs = t;
sl_bs = 0;
}
} else {
if (sl_bs == 0) {
sl_bs = t;
sl_fs = 0;
}
}

var nf = -mySpeedToMe.Z;
if(nf<0)nf=0;
aeroSpeedLevel = (int)nf / 10;
}

void aeroSLz() {
if (sl_fs != 0 && t - sl_fs > 180) aeroSpeedLevel = 10;
if (sl_bs != 0 && t - sl_bs > 180) aeroSpeedLevel = 0;
sl_fs = 0;
sl_bs = 0;
}

float ft = 0f;
Vector3D mySpeedToMe = Vector3D.Zero;

List<IMySensorBlock> sensors = new List<IMySensorBlock>();
long lastMotherSignalTime=0;

bool init = false;
bool configFinish = false;
IMyShipController Cockpit;
IMyShipController msc;
IMyTerminalBlock fighterFcs = null;
List<IMyTextSurface> LCD = new List<IMyTextSurface>();
List<IMyTerminalBlock> Gyroscopes;
string[] gyroYawField = null;
string[] gyroPitchField = null;
string[] gyroRollField = null;
string[] gyroYawFieldHead = null;
string[] gyroPitchFieldHead = null;
string[] gyroRollFieldHead = null;
float[] gyroYawFactor = null;
float[] gyroPitchFactor = null;
float[] gyroRollFactor = null;
float[] gyroYawFactorHead = null;
float[] gyroPitchFactorHead = null;
float[] gyroRollFactorHead = null;
const float GYRO_FACTOR = 1f;
int t = 1;
Vector3D MePosition = Vector3D.Zero;
double AimRatio = 0.5;
double maxAV = 1;
Vector3D MeLastPosition;
Vector3D MeVelocity;
Vector3D MeLastVelocity;
Vector3D MeAcceleration;
Vector3D inputVec;
Vector3D inputVec_RT = Vector3D.Zero;
float inputRoll;
bool isUnderControl = false;
MyShipMass myShipMass;
float shipMass;
MatrixD refLookAtMatrix;
MatrixD refMatrix;

Vector3D LockTargetPosition = Vector3D.Zero;
bool LockTargetAiming = false;
Vector3D LockTargetVelocity = Vector3D.Zero;
Vector3D radarHighThreatPosition = Vector3D.Zero;
List<Vector3D> LTPs = new List<Vector3D>();
List<Vector3D> LTVs = new List<Vector3D>();

int lastSendingTime = 0;
int lastReceivingTime = 0;

Vector3D maintainSpeedToMeAA = Vector3D.Zero;

// float mode
bool floatModeOn = false;
bool isVF=true;
IMyShipController Head;
List<IMyTerminalBlock> rotorShoulder = new List<IMyTerminalBlock>();
string RotorShoulderNameTag = "Rotor Shoulder";
PIDController[] shoulderPIDList = new PIDController[2];
int legMode = 0;
float legMargin = 0.05f * (float)Math.PI;
int legFoldStart = 0;
int legFoldTime = 120;
List<IMyCameraBlock> cameraList = new List<IMyCameraBlock>();
double fme = 100;
List<IMyTerminalBlock> lcdBackList = new List<IMyTerminalBlock>();

// new down mode
Vector3D downStartPos = Vector3D.Zero;
int lastDownT = 0;

// auto fire missile
int msBuildStart = 0;
int msBuildInterval = 60 * 60;
string MISSILE_TAG="#A#";

// sm mode
bool isSM = false;

// auto height hold
bool ahhOn = false;
bool continueAhhOn = false;
int continueAhhStart = 0;
void setAhhOn(bool v) {
ahhOn = v;
if (ahhOn == false) {
continueAhhOn = false;
continueAhhStart = 0;
} else {
if (continueAhhStart == 0) continueAhhStart = t;
else if ( t > continueAhhStart + 180 ) continueAhhOn = true;
}
}
bool useAhh = true;
double ahh = 0;

// suspect mode
bool susMode = false;
int lastNoHighSpeed = 0;

Program()
{
//Runtime.UpdateFrequency = UpdateFrequency.Update1;
}

void Main(string arguments, UpdateType updateType)
{
Runtime.UpdateFrequency = UpdateFrequency.Update1;
if ((updateType & UpdateType.Update1) != 0) {
arguments = "";
}

if (!configFinish) {
ProcessCustomConfiguration();
configFinish = true;
}

if(!init)
{
GetBlocks(arguments);
t++;
return;
}

if ((updateType & UpdateType.Update1) !=0)
  NavigationInfoUpdata(true);
List<IMyTerminalBlock> welderList;
switch (arguments)
{
case ("CONTROL"):
attackMode=false;
flyByOn=false;
dockingOn=false;
resetThrusters();
isApproach=false;
PlayActionList(connectors, "OnOff_On");
PlayActionList(landingGears, "OnOff_On");
SetGyroOverride(false);
break;
case ("FLYBY"):
if (sonCode == null) break;
attackMode=false;
flyByOn = !flyByOn;
if (flyByOn) {
dockingOn=false;
setDampenersOverride(Cockpit, false);
PlayActionList(thrusters, "OnOff_On");
setAhhOn(false);
PlayActionList(connectors, "OnOff_Off");
PlayActionList(landingGears, "OnOff_Off");
}
if (!flyByOn) {
resetThrusters();
isApproach=false;
PlayActionList(connectors, "OnOff_On");
PlayActionList(landingGears, "OnOff_On");
SetGyroOverride(false);
}
break;
case ("FLYBYON"):

break;
case ("DOCKING"):
if (sonCode == null) break;
attackMode=false;
dockingOn = !dockingOn;
if (dockingOn) {
flyByOn=false;
setDampenersOverride(Cockpit, false);
PlayActionList(thrusters, "OnOff_On");
setAhhOn(false);
PlayActionList(connectors, "OnOff_On");
PlayActionList(landingGears, "OnOff_On");
}
if (!dockingOn) {
resetThrusters();
PlayActionList(connectors, "OnOff_On");
PlayActionList(landingGears, "OnOff_On");
SetGyroOverride(false);
}
break;
case ("DOCKINGON"):
break;
case ("ATTACKON"):
break;
case ("ATTACKOFF"):
break;
case ("WEAPON1"):
break;
case ("WEAPON2"):
break;
case ("LOADMISSILE"):
welderList = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyShipWelder> (welderList);
PlayActionList(welderList, "OnOff_On");
break;
case ("FIREMISSILE"):
fireMissile();
break;
case ("LOADMISSILEON"):
break;
case ("FIREMISSILEON"):
break;
case "DETRANSON":
break;
case "TRANSON":
break;
case "RULER":
setRulerOnOff(!rulerOn);
break;
case "DOWN":
isDown = !isDown;
if (isDown) {
isLaunch=false;
downStartPos = MePosition;
} else {
SetGyroOverride(false);
}
resetThrusters();
break;
case "LAUNCH":
isLaunch = !isLaunch;
if (isLaunch) {
isDown=false;
} else {
SetGyroOverride(false);
}
resetThrusters();
break;
case "RESET":
init = false;
break;
case "POINT":
motherPointerMode = !motherPointerMode;
break;
case "ATTACK":
if (flyByOn) {
attackMode = !attackMode;
}
break;
case "RPW":
{
double l,u,f;
string h,t;
l = u = f = 0;
h = t = "";
recordNp(out l,out u,out f,out h,out t);
switch(t) {
case("UP"):
if (Math.Abs(l)>20) {
cfg.Set("flyByOffsetDirection", "LEFT");
cfg.Set("flyByDistance",""+l);
cfg.Set("flyByForwardDistance", ""+f);
cfg.Set("flyByUpDistance", ""+u);
} else if (h=="BACKWORD") {
cfg.Set("flyByOffsetDirection", "BACKWARD");
cfg.Set("flyByDistance",""+(-f));
cfg.Set("flyByUpDistance", ""+u);
} else {
cfg.Set("flyByDistance",""+u);
cfg.Set("flyByOffsetDirection", "UP");
cfg.Set("flyByForwardDistance", ""+f);
}
break;
case("DOWN"):
cfg.Set("flyByDistance",""+(-u));
cfg.Set("flyByOffsetDirection", "DOWN");
cfg.Set("flyByForwardDistance", ""+f);
break;
case("LEFT"):
cfg.Set("flyByDistance",""+l);
cfg.Set("flyByOffsetDirection", "LEFT");
cfg.Set("flyByForwardDistance", ""+f);
cfg.Set("flyByUpDistance", ""+u);
break;
case("RIGHT"):
cfg.Set("flyByDistance",""+(-l));
cfg.Set("flyByOffsetDirection", "RIGHT");
cfg.Set("flyByForwardDistance", ""+f);
cfg.Set("flyByUpDistance", ""+u);
break;
}
cfg.Save();
}
break;
case "RPP":
{
double l,u,f;
string h,t;
l = u = f = 0;
h = t = "";
recordNp(out l,out u,out f,out h,out t);
cfg.Set("dockingApproachDistanceLeft",""+l);
cfg.Set("dockingApproachDistanceUp",""+u);
cfg.Set("dockingApproachDistanceForward",""+f);
cfg.Save();
}
break;
case "RPD":
{
double l,u,f;
string h,t;
l = u = f = 0;
h = t = "";
recordNp(out l,out u,out f,out h,out t);
if (connectors.Count>0){
Base6Directions.Direction cUp = connectors[0].WorldMatrix.GetClosestDirection(Cockpit.WorldMatrix.Up);
switch (cUp)
{
case Base6Directions.Direction.Forward:
u += -4;
break;
case Base6Directions.Direction.Backward:
u += 4;
break;
default:
f += 4;
break;
}
}

cfg.Set("dockingForward",h);
cfg.Set("dockingUp",t);
cfg.Set("dockingLeftDistance",""+l);
cfg.Set("dockingUpDistance",""+u);
cfg.Set("dockingForwardDistance",""+f);
cfg.Save();
}
break;
case "FLOAT":
floatModeOn = !floatModeOn;
break;
case "WALKMODE":
if (legMode<2) break;
if (legMode == 2) {
legMode = 3;
PlayActionList(thrusters, "OnOff_Off");
PlayActionList(spotlights, "OnOff_Off");
} else {
legMode = 2;
PlayActionList(thrusters, "OnOff_On");
PlayActionList(spotlights, "OnOff_On");
}
break;
default:
if (sonCode == null) break;
if(arguments!=null && arguments != "") {
ParseMaintainSpeed(arguments);
lastReceivingTime=t;
}
break;
case "SM":
isSM = !isSM;
break;
}

if ((updateType & UpdateType.Update1) == 0) {
ShowLCD();
return;
}

switch(commandCache) {
case "FLYBYON":
if(shipPosition==Vector3D.Zero) break;
if ( t > commandStart + commandWaitTic) {
startFlyBy();
setAhhOn(false);
commandCache=null;
}
break;
case "DOCKINGON":
if ( t > commandStart + (commandAllTic-commandWaitTic)) {
startDocking();
setAhhOn(false);
commandCache=null;
}
break;
default:
break;
}

t++;

if (t > lastMotherSignalTime + 120) {
ParseSensor();
}

if (gcTargetPanel != null) {
if (!LockTargetPosition.Equals( Vector3D.Zero)) {
gcTargetPanel.WritePublicTitle("[T:" + LockTargetPosition.X + ":" + LockTargetPosition.Y + ":" + LockTargetPosition.Z + ":"
+ LockTargetVelocity.X + ":" + LockTargetVelocity.Y + ":" + LockTargetVelocity.Z);

for (int i = 0; i < maxTargetCount; i++ ){
if (i >= gcTargetPanelList.Count) break;
var cp = gcTargetPanelList[i];
int vi = i % LTPs.Count;
cp.WritePublicTitle("[T:" + LTPs[vi].X + ":" + LTPs[vi].Y + ":" + LTPs[vi].Z + ":"
+ LTVs[vi].X + ":" + LTVs[vi].Y + ":" + LTVs[vi].Z);
}

} else {
gcTargetPanel.WritePublicTitle("");
for (int i = 0; i < maxTargetCount; i++ ){
if (i >= gcTargetPanelList.Count) break;
var cp = gcTargetPanelList[i];
cp.WritePublicTitle("");
}


}
}

ShowLCD();
NavigationInfoUpdata(false);
if (inputVec != null)inputVec_RT = inputVec;
else inputVec_RT = Vector3D.Zero;
debugInfo = "t1" + displayVector3D(inputVec_RT) + "\n";
if(notDocked()) {
if ( dockingOn && dockable() ) {
PlayActionList(landingGears, "Lock");
return;
}
} else {
if (dockingOn ) {
PlayActionList(thrusters, "OnOff_Off");
for (int i = 0; i < offGridThrust.Count; i++) {
offGridThrust[i].Enabled=false;
}
SetGyroOverride(false);
PlayActionList(spotlights, "OnOff_Off");
}
}

bool needGyroOverride = false;

if (sonCode != null) {
if(notDocked()) MaintainSpeed();
}

// turning
if (flyByOn || dockingOn ) {
setRulerOnOff(false);
}
if (rulerOn) {
if (homingTurret!=null){
Vector3D direction;
Vector3D.CreateFromAzimuthAndElevation(homingTurret.Azimuth, homingTurret.Elevation, out direction);
if (Math.Abs(homingTurret.Azimuth) > 0.02f) {
SetGyroYaw(-30*homingTurret.Azimuth);
} else {
SetGyroYaw(0);
}
if (Math.Abs(homingTurret.Elevation) > 0.02f) {
SetGyroPitch(30*homingTurret.Elevation);
} else {
SetGyroPitch(0);
}
//SetGyroOverride(true);
needGyroOverride = true;
}
}

// auto balance in gravity
var ng = naturalGravity;
bool isAssist = isDown || isLaunch || (floatModeOn&&isVF) || isSM || continueAhhOn;
bool suc = isUnderControl;
bool tuc = homingTurret != null && homingTurret.IsUnderControl;
if (!suc && !isHold && ng.Length() > 0.001f &&
!(flyByOn||dockingOn||isDown||isLaunch||((floatModeOn&&isVF))||isSM)
) {
holdPosition = MePosition;
isHold = true;
resetThrusters();
}

if ((!(flyByOn||dockingOn) && ng.Length() > 0.001f && !rulerOn && dampenersOn) || isAssist) {
if (!suc || isAssist) {

// CODING
if(ng.Length() > 0.001 && !(LockTargetAiming && LockTargetPosition!=Vector3D.Zero)) {
var forward = msc.WorldMatrix.Forward;
var left = msc.WorldMatrix.Left;
var diff = diffGravity(left, ng, forward);
if (diff != 0) {
SetGyroRoll(diff * AimRatio * 60 * -1);
}
diff = diffGravity(forward, ng, -left);
if(isDown && legMode<2) {
diff += angleWhenDown;
}
if (LockTargetPosition.Equals(Vector3D.Zero) && !isSM && !tuc) {
SetGyroPitch(diff * AimRatio * 60);
SetGyroYaw((msc.RotationIndicator.Y) * 30);
} else {
// rix = -Y riy = X
SetGyroPitch((-msc.RotationIndicator.X) * 30);
SetGyroYaw((msc.RotationIndicator.Y) * 30);
}

//SetGyroOverride(true);
needGyroOverride = true;

}

bool sma = LockTargetPosition!=Vector3D.Zero && isSM;
if ((!suc&&!floatModeOn) || isDown || isLaunch || sma){
Vector3D needSpeed = (holdPosition - MePosition) * 0.1f - MeVelocity;
debugInfo += displayVector3D(holdPosition) + "\n";
debugInfo += displayVector3D(MePosition) + "\n";
Vector3D maintainSpeedToMe = Vector3D.TransformNormal(needSpeed, refLookAtMatrix);
debugInfo += "Y0\n";

Vector3D nowSpeedToMe = Vector3D.TransformNormal(Cockpit.GetShipVelocities().LinearVelocity, refLookAtMatrix);
if (isDown) {
var ds = -2;
Vector3D mstm = Vector3D.Zero;
if(naturalGravityLength > 0.01) {
mstm = - Vector3D.Normalize(naturalGravity) * ds;
Vector3D downAim = MePosition - downStartPos;
downAim = Vector3D.Reject(downAim, Vector3D.Normalize(naturalGravity));
mstm += -5 * downAim;
mstm = Vector3D.TransformNormal(mstm, refLookAtMatrix);
} else {
mstm = new Vector3D(0, ds, 0);
}
maintainSpeedToMe = mstm - nowSpeedToMe;
debugInfo += "Y1\n";
}else if (isLaunch){
maintainSpeedToMe = new Vector3D(0,90,0);
debugInfo += "Y2\n";
}else if (sma){
maintainSpeedToMe = Vector3D.TransformNormal(LockTargetVelocity, refLookAtMatrix) - nowSpeedToMe;
maintainSpeedToMe += inputVec * 10;
debugInfo += "Y3\n";
}
forwardMoveIndicator=0;//auto balance
DimSpeedAll(maintainSpeedToMe, refLookAtMatrix);
inputVec_RT = maintainSpeedToMe * 1f; //CODING
debugInfo += "t2" + displayVector3D(inputVec_RT) + "\n";

}

} else {
if(isHold) {
isHold = false;
//SetGyroOverride(false);
resetThrusters();
}
}
}

if (floatModeOn && naturalGravityLength > 0 ) {
var naturalGravityNormal = Vector3D.Normalize(naturalGravity);
if (cameraList.Count > 0 && !isVF) {
var ca = cameraList[0];
if (ca.AvailableScanRange > 150) {
var me = ca.Raycast(MePosition+ 100*naturalGravityNormal);
if (me.EntityId != 0){
fme = ((me.HitPosition ?? MePosition) - MePosition).Length();
}else fme = 100;
}
}else{
fme=100;
}
Vector3D aSpeed;
if (fme > 3) {
double tmps =  (fme - 3)/10 + 1;
if (tmps>10)tmps=10;
aSpeed = tmps * naturalGravityNormal;
} else if (fme < 1) {
aSpeed = -2 * naturalGravityNormal;
} else {
aSpeed = (fme - 2) * naturalGravityNormal;
}

Vector3D needSpeed = aSpeed - MeVelocity;
Vector3D maintainSpeedToMe = Vector3D.TransformNormal(needSpeed, refLookAtMatrix);
Vector3D nowSpeedToMe = Vector3D.TransformNormal(Cockpit.GetShipVelocities().LinearVelocity, refLookAtMatrix);

forwardMoveIndicator=0;// float mode
var nud = Cockpit.WorldMatrix.Up.Dot(naturalGravity);
DimSpeed(maintainSpeedToMe.Y, upThrusters, downThrusters, ref thrusterPercentY, nowSpeedToMe.Y, lastSpeedY, "UP".Equals(dockingApproach)||"DOWN".Equals(dockingApproach), nud,1);
lastSpeedY = nowSpeedToMe.Y;

if (isUnderControl) {
if (inputVec.Z > 0.1) {
SetThrusterListOverride(backwardThrusters, 100f);
SetBlocksValueColor(lcdBackList, "BackgroundColor", new Color(128,0,0));
}else {
SetThrusterListOverride(backwardThrusters, 0f);
SetBlocksValueColor(lcdBackList, "BackgroundColor", new Color(1,1,1));
}
} else {
SetThrusterListOverride(backwardThrusters, -1f);
SetBlocksValueColor(lcdBackList, "BackgroundColor", new Color(1,1,1));
}
}
if (isUnderControl && ahhOn && !isDown && !isLaunch) {
double h = 0;
bool getted = msc.TryGetPlanetElevation(MyPlanetElevation.Sealevel, out h);
if (getted) {
var needD = ahh - h;
needD = needD / (Vector3D.Dot(-Vector3D.Normalize(naturalGravity), msc.WorldMatrix.Up)); // CODING
var needV = needD;
var m2m = mySpeedToMe;
var needA = (needV - m2m.Y) ; // coding
inputVec_RT.Y = needA;
debugInfo += "t3" + displayVector3D(inputVec_RT) + "\n";
var nud = Cockpit.WorldMatrix.Up.Dot(naturalGravity);
string dsdr = DimSpeed(needA, upThrusters, downThrusters, ref thrusterPercentY, m2m.Y, lastSpeedY, "UP".Equals(dockingApproach)||"DOWN".Equals(dockingApproach), nud,1);
lastSpeedY = m2m.Y;
}
}

if(!(flyByOn||dockingOn||isSM)){
// auto forward
if(Math.Abs(inputVec.Z) < 0.1 && aeroSpeedLevel>0 ){
ft = (float)MathHelper.Clamp(((-10*aeroSpeedLevel) - mySpeedToMe.Z) * 0.1, -10, 10);
var needForce = (Vector3D.Dot(-naturalGravity, msc.WorldMatrix.Backward) + ft) * shipMass;
if(ft < 0){
inputVec_RT.Z = ft;
debugInfo += "t4" + displayVector3D(inputVec_RT) + "\n";
double allForce = 0;
foreach(var t in forwardThrusters) {
  allForce += ((IMyThrust)t).MaxEffectiveThrust;
}
float percent = 0;
if(allForce > 0) percent=(float) (-needForce/allForce);

SetThrusterListOverride(forwardThrusters, percent);
SetThrusterListOverride(backwardThrusters, 0);
}else {
if (naturalGravityLength>0.01){ //CODING
inputVec_RT.Z = ft;
debugInfo += "t5" + displayVector3D(inputVec_RT) + "\n";
double allForce = 0;
foreach(var t in backwardThrusters) {
  allForce += ((IMyThrust)t).MaxEffectiveThrust;
}
float percent = 0;
if(allForce > 0) percent=(float) (needForce/allForce);

SetThrusterListOverride(forwardThrusters, 0);
SetThrusterListOverride(backwardThrusters, percent);
}
}
} else {
SetThrusterListOverride(forwardThrusters, -1f);
SetThrusterListOverride(backwardThrusters, -1f);
}
}

// start dummy
if (isDummy) {
if (!isDummyInit) {
dummyP = MePosition;
isDummyInit=true;
dummyT = dummyP + new Vector3D(rnd.Next(10,1000),rnd.Next(10,1000),rnd.Next(10,1000));
}
if (t%600 == 0)dummyT = dummyP + new Vector3D(rnd.Next(10,1000),rnd.Next(10,1000),rnd.Next(10,1000));
Vector3D dummySpeed = dummyT - MePosition;

Vector3D maintainSpeedToMe = Vector3D.TransformNormal(dummySpeed - Cockpit.GetShipVelocities().LinearVelocity, refLookAtMatrix);
inputVec_RT = maintainSpeedToMe;
debugInfo += "t6" + displayVector3D(inputVec_RT) + "\n";
 if (maintainSpeedToMe.Length() > 50){
// 高差速指向
Vector3D d = Vector3D.Normalize(maintainSpeedToMe);
if (d.Z > 0.5) {
d = new Vector3D(1,0,0);
}
SetGyroYaw(AimRatio*d.X*60);
SetGyroPitch(AimRatio*d.Y*60);
d.Z=0;
//SetGyroOverride(true);
needGyroOverride = true;

}
DimSpeedAll(maintainSpeedToMe,refLookAtMatrix);
}

if(LockTargetAiming && LockTargetPosition!=Vector3D.Zero) needGyroOverride = true;

if((flyByOn || dockingOn) && notDocked()) needGyroOverride = true;
SetGyroOverride(needGyroOverride);

Main_RT(arguments, updateType); // calc thrustNeedDir need to be in front of main_vt

Main_VT();
}

Vector3D dummyP;
bool isDummyInit = false;
bool isDummy = false;
Vector3D dummyT;
Random rnd = new Random();

void VFTransform(int mode) {
if(rotorShoulder.Count ==0) return;
float tsl;
if (mode == 1) {
tsl = 0;
} else if (mode ==2) {
tsl = 0.5f * (float)Math.PI;
} else {
tsl = 0.8f * mpi;
}

for (int i = 0; i < rotorShoulder.Count; i++) {
IMyMotorStator r = (IMyMotorStator) rotorShoulder[i];
if ( i == 0) {
r.SetValueFloat("Velocity", (float)shoulderPIDList[0].Filter(tsl - modangle(r.Angle),2));
} else {
r.SetValueFloat("Velocity", (float)shoulderPIDList[0].Filter(-tsl - modangle(r.Angle),2));
}
}
}

void NavigationInfoUpdata(bool before)
{
if (Head != null && Head.IsUnderControl) {
msc = Head;
} else {
msc = Cockpit;
}
refLookAtMatrix = MatrixD.CreateLookAt(new Vector3D(), msc.WorldMatrix.Forward, msc.WorldMatrix.Up);
refMatrix = msc.WorldMatrix;
if(before)
{
MePosition = msc.CenterOfMass;
MeVelocity = msc.GetShipVelocities().LinearVelocity;
MeAcceleration = (MeVelocity-MeLastVelocity)*60;

myShipMass = msc.CalculateShipMass();
shipMass = myShipMass.PhysicalMass;
naturalGravity = Cockpit.GetNaturalGravity();
naturalGravityLength = naturalGravity.Length();
dampenersOn = Cockpit.DampenersOverride;

if(Head != null ) {
if (Head.IsUnderControl) {
if (legMode == 1) {
legMode = 2;
}
} else {
if (legMode == 2) {
legMode = 1;
}
}
VFTransform(legMode);
}
isUnderControl = false;
inputVec = Vector3D.Zero;
inputRoll = 0;
if (Head != null && Head.IsUnderControl) {
inputVec = Head.MoveIndicator;
inputRoll = Head.RollIndicator;
isUnderControl = true;
} else if (Cockpit.IsUnderControl){
inputVec = Cockpit.MoveIndicator;
inputRoll = Cockpit.RollIndicator;
isUnderControl = true;
}
if(isUnderControl) {

if(inputVec.Z>0.1) {
aeroSLp(false);
} else if(inputVec.Z<-0.1) {
aeroSLp(true);
} else {
aeroSLz();
}

if (inputVec.Length()<0.01&&MeVelocity.Length()>10){
SetThrusterListOverride(backwardThrusters, 0f);
}
if(inputVec.Z > 0.1){
SetThrusterListOverride(backwardThrusters, -1f);
}
// ahh
Vector3D inputVecWorld = Vector3D.TransformNormal(inputVec, msc.WorldMatrix);
bool wantUD = false;
if (naturalGravity.Length() > 0.1 && inputVec.Length() >0.1) {
  wantUD = Math.Abs(inputVecWorld.Dot(Vector3D.Normalize(naturalGravity))) > 0.1;
}
if (!wantUD) {
var forward = msc.WorldMatrix.Forward;
var left = msc.WorldMatrix.Left;
var diffZ = diffGravity(forward, naturalGravity, -left);
if (Math.Abs(diffZ) > 0.2) wantUD = true;
}
if (!wantUD && isUnderControl) {
if (msc.RotationIndicator.Length() > 0.1
|| Math.Abs(inputRoll) > 0.1
) {
wantUD = true;
}
}

if (useAhh && !wantUD && !(flyByOn || dockingOn)) {

if (!ahhOn) {
double h = 0;
if (msc.TryGetPlanetElevation(MyPlanetElevation.Sealevel, out h)) {
ahh = h;
setAhhOn(true);
}
} else {
setAhhOn(true);
}
}
if (wantUD) {
setAhhOn(false);
resetThrusters(false);
}
}
bool cd = false;
if ( inputVec.Y < -0.5 && lastDownT == 0) {
var forward = msc.WorldMatrix.Forward;
var left = msc.WorldMatrix.Left;
var diffX = diffGravity(left, naturalGravity, forward);
var diffZ = diffGravity(forward, naturalGravity, -left);
if (Math.Abs(diffX)<0.2 && Math.Abs(diffZ)<0.2 && MeVelocity.Length() < 30) {
lastDownT = t;
}
} else if (Math.Abs(inputVec.Y) < 0.1 && lastDownT != 0) {
if( t - lastDownT < 10) {
isDown = true;
cd = true;
}
lastDownT = 0;
} else if (inputVec.Y > 0.5) {
isDown = false;
cd = true;
}
if(cd){
if (isDown) {
isLaunch=false;
downStartPos = MePosition;
} else {
SetGyroOverride(false);
}
resetThrusters();
}


// parse locktarget from fcs
if (fighterFcs != null) {
CustomConfiguration cfgTarget = new CustomConfiguration(fighterFcs);
cfgTarget.Load();

string tmpS = "";
cfgTarget.Get("Position", ref tmpS);
Vector3D.TryParse(tmpS, out LockTargetPosition);
if(LockTargetPosition==Vector3D.Zero) isSM=false;
cfgTarget.Get("Aiming", ref tmpS);
LockTargetAiming = tmpS == "True";
// if fcs have target launch missile immediatly
if(LockTargetPosition!=Vector3D.Zero && flyByOn ) fireMissile();

cfgTarget.Get("Velocity", ref tmpS);
Vector3D.TryParse(tmpS, out LockTargetVelocity);

cfgTarget.Get("radarHighThreatPosition", ref tmpS);
Vector3D.TryParse(tmpS, out radarHighThreatPosition);

int tmpI = 0;
cfgTarget.Get("TargetCount", ref tmpI);

int targetCount = tmpI;
LTPs.Clear();
LTVs.Clear();
for (int i = 0; i < targetCount; i++) {
Vector3D tmpP, tmpV;
cfgTarget.Get("Position"+i, ref tmpS);
Vector3D.TryParse(tmpS, out tmpP);
LTPs.Add(tmpP);
cfgTarget.Get("Velocity"+i, ref tmpS);
Vector3D.TryParse(tmpS, out tmpV);
LTVs.Add(tmpV);
}

}
}
else
{
MeLastPosition = Cockpit.CenterOfMass;
MeLastVelocity = Cockpit.GetShipVelocities().LinearVelocity;
}
mySpeedToMe = Vector3D.TransformNormal(MeVelocity, refLookAtMatrix);
}


void resetThrusters(bool needD = true){
if(needD)setDampenersOverride(Cockpit, true);
for (int i = 0; i < thrusters.Count; i++) {
PlayAction(thrusters[i], "OnOff_On");
thrusters[i].SetValue("Override", 0f);
}
}

Vector3D CalculateTurretViewVector(IMyLargeTurretBase turret)
{
Vector3D direction;
Vector3D.CreateFromAzimuthAndElevation(turret.Azimuth, turret.Elevation, out direction);

return Vector3D.TransformNormal(direction, turret.WorldMatrix);
}

double diffGravity(Vector3D dir, Vector3D ng, Vector3D axis) {
if (ng.Length() == 0) return 0;
var naturalGravityLength = ng.Length();
var ngDir = Vector3D.Normalize(ng);
var vertialPlaneLaw = Vector3D.Normalize(new Vector3D(ngDir.Y * axis.Z - ngDir.Z * axis.Y,
ngDir.Z * axis.X - ngDir.X * axis.Z,
ngDir.X * axis.Y - ngDir.Y * axis.X));
var angle = Math.Asin(dir.Dot(vertialPlaneLaw));
var diff = Math.PI / 2 + angle;
var leftOrRight = Math.Acos(dir.Dot(ngDir));
if (leftOrRight > Math.PI / 2) {
diff = -diff;
}

if (Math.Abs(diff) > 0.0001f) {
return diff;
}else {
return 0;
}

}

void PlayAction(IMyTerminalBlock block, String action) {
if (block != null) {
var a = block.GetActionWithName(action);
if (a!=null) a.Apply(block);
}
}

void PlayAction(IMyTerminalBlock block, String action, List<TerminalActionParameter> args = null) {
if (block != null) {
block.GetActionWithName(action).Apply(block, args);
}
}

void PlayActionList(List<IMyTerminalBlock> blocks, String action) {
if(blocks == null) return;
for(int i = 0; i < blocks.Count; i ++)
{
blocks[i].GetActionWithName(action).Apply(blocks[i]);
}
}


void ShowLCD()
{
string br = "\n";

string info = "";
info += (rulerOn?"Turning":"") + "  Auto:  " + (flyByOn ? "Wing" : "") + (dockingOn ? "Landing" : "") + (attackMode ? "Attack" : "") + (isApproach ? "Near" : "") + "    " + (isDown?"Down":"") + (isLaunch?"Launching":"") +  (isSM?"Speed Match":"") + br;
info += (motherPointerMode?"Pointing":"") + " " +(motherCode!=null?"M: "+motherCode:"") + " " + (sonCode!=null?"S: "+sonCode:"") + (t - lastSendingTime<120 && t%60<30 ?"=>":"") + (t - lastReceivingTime<120 && t%60<30?"<=":"") + br;
info += "Speed level: " + aeroSpeedLevel + '\n';
info += " Location " + distanceInfo + br;
if (gcTargetPanel != null) {
info += " Target: " + gcTargetPanel.GetPublicTitle() + "\n";
}

info += " Relative Position: (l u f h t)\n";
info += " Wing: " + op2npd(flyByOffsetDirection, upMode, flyByDistance, flyByUpDistance, flyByForwardDistance) + "\n";
info += " Prepare: " + r2(dockingApproachDistanceLeft) + " # " + r2(dockingApproachDistanceUp) + " # " + r2(dockingApproachDistanceForward) + " # " + dd(dockingForward) + " # " + dd(dockingUp) + "\n";
info += " Dock: " + r2(dockingLeftDistance) + " # " + r2(dockingUpDistance) + " # " + r2(dockingForwardDistance) + " # " + dd(dockingForward) + " # " + dd(dockingUp) + "\n";

info += debugInfo + br;

for(int i = 0; i < LCD.Count; i ++)
{
IMyTextSurface lcd = LCD[i] as IMyTextSurface;
lcd.WriteText(info);
if(flyByOn || dockingOn) {
if(isApproach) lcd.FontColor = new Color(76,255,0);
else lcd.FontColor = new Color(255,76,0);
} else {
lcd.FontColor = new Color(0,76,255);
}
}

}

void recordNp(out double l, out double u , out double f, out string h, out string t) {
shipPosition = new Vector3D(shipMatrix.M41, shipMatrix.M42, shipMatrix.M43);
Vector3D myPosition = MePosition;
Vector3D myToShipPosition = myPosition - shipPosition;
MatrixD shipLookAtMatrix = MatrixD.CreateLookAt(new Vector3D(0,0,0), shipMatrix.Forward, shipMatrix.Up);
myToShipPosition = Vector3D.TransformNormal(myToShipPosition, shipLookAtMatrix);
l = Math.Round(-myToShipPosition.X,2);
u = Math.Round(myToShipPosition.Y,2);
f = Math.Round(-myToShipPosition.Z,2);
Base6Directions.Direction s2mh = shipMatrix.GetClosestDirection(Cockpit.WorldMatrix.Forward);
switch (s2mh)
{
case Base6Directions.Direction.Forward:
h="FORWARD";
break;
case Base6Directions.Direction.Backward:
h="BACKWARD";
break;
case Base6Directions.Direction.Up:
h="UP";
break;
case Base6Directions.Direction.Down:
h="DOWN";
break;
case Base6Directions.Direction.Left:
h="LEFT";
break;
case Base6Directions.Direction.Right:
h="RIGHT";
break;
default:
h="";
break;
}
Base6Directions.Direction s2mt = shipMatrix.GetClosestDirection(Cockpit.WorldMatrix.Up);
switch (s2mt)
{
case Base6Directions.Direction.Forward:
t="FORWARD";
break;
case Base6Directions.Direction.Backward:
t="BACKWARD";
break;
case Base6Directions.Direction.Up:
t="UP";
break;
case Base6Directions.Direction.Down:
t="DOWN";
break;
case Base6Directions.Direction.Left:
t="LEFT";
break;
case Base6Directions.Direction.Right:
t="RIGHT";
break;
default:
t="";
break;
}
}

string op2npd(string dir, bool isUp, double d, double u, double f) {
string r="";
switch(dir) {
case("FORWARD"):
r = "0" + " # " + r2(u) + " # " + r2(d) + " # " + "f" + " # " + "u";
break;
case("BACKWARD"):
r = "0" + " # " + r2(u) + " # " + r2(-d) + " # " + (isUp?"f":"b") + " # " + "u";
break;
case("UP"):
r = "0" + " # " + r2(d) + " # " + r2(f) + " # " + "f" + " # " + "u";
break;
case("DOWN"):
r = "0" + " # " + r2(-d) + " # " + r2(f) + " # " + "f" + " # " + (isUp?"u":"d");
break;
case("LEFT"):
r = r2(d) + " # " + r2(u) + " # " + r2(f) + " # " + "f" + " # " + (isUp?"u":"l");
break;
case("RIGHT"):
r = r2(-d) + " # " + r2(u) + " # " + r2(f) + " # " + "f" + " # " + (isUp?"u":"r");
break;
}
return r;
}

string r2 (double d) {
return "" + Math.Round(d, 2);
}

string dd(string dir) {
string r = "";
switch(dir) {
case("FORWARD"):
r = "f";
break;
case("BACKWARD"):
r = "f";
break;
case("UP"):
r = "u";
break;
case("DOWN"):
r = "d";
break;
case("LEFT"):
r = "l";
break;
case("RIGHT"):
r = "r";
break;
}
return r;
}

void SetBlocksValueColor(List<IMyTerminalBlock> blocks, String name, Color v) {
for(int i = 0; i < blocks.Count; i ++)
{
blocks[i].SetValue(name, v);
}
}

// utils
IMyTerminalBlock getBlockByName(string name, bool sameGrid = true, bool sameName = false) {
List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.SearchBlocksOfName(name, blocks);
if (sameGrid) FilterSameGrid(Me.CubeGrid, ref blocks);
if (sameName) FilterSameName(name, ref blocks);
if (blocks.Count > 0) return blocks[0];
return null;
}

List<IMyTerminalBlock> getBlockListByName(string name) {
List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.SearchBlocksOfName(name, blocks);
FilterSameGrid(Me.CubeGrid, ref blocks);
return blocks;
}

void GetBlocks(String args)
{
List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyShipConnector>(blocks);
FilterSameGrid(Me.CubeGrid, ref blocks);
connectors = blocks;
blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyLandingGear>(blocks);
FilterSameGrid(Me.CubeGrid, ref blocks);
landingGears = blocks;
if (ptdSeparatedStart == 0 && !TestNotConnected(connectors) && !isBase) {
isApproach=true;
PlayActionList(connectors, "Unlock");
return;
}
if (isPrinted) {
Echo("PTD1");
if (args.Equals("PTD")) {
isPtdTurnOn = true;
cfg.Set("isPrinted","false");
cfg.Save();
}
if (!isPtdTurnOn) {
return;
}
if (ptdSeparatedStart == 0) {
blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyShipMergeBlock>(blocks, b => b.CubeGrid == Me.CubeGrid);
PlayActionList(blocks, "OnOff_Off");
ptdSeparatedStart = t;
}

if (ptdSeparatedStart > 0 && t > ptdSeparatedStart && t < ptdSeparatedStart + 182) {
PlayActionList(connectors, "Lock");
}

if (ptdSeparatedStart > 0 && t > ptdSeparatedStart + 182 && t < ptdSeparatedStart + 200) {
PlayActionList(connectors, "Unlock");
flyByOn = true;
isApproach = true;
}

if (ptdSeparatedStart == 0 || t < ptdSeparatedStart + 200) {
return;
}

}

if ((!notDocked() || dockable()) && !isBase){
dockingOn=true;
isApproach = true;
}
Cockpit = getBlockByName(CockpitNameTag) as IMyShipController;
if(Cockpit == null)
{Echo(CockpitNameTag  + "未找到"); return;}
setDampenersOverride(Cockpit, true);
refLookAtMatrix = MatrixD.CreateLookAt(new Vector3D(), Cockpit.WorldMatrix.Forward, Cockpit.WorldMatrix.Up);

Head = getBlockByName(HeadNameTag) as IMyShipController;
if (Head != null) {
legMode = 1;
List<IMyTerminalBlock> tmprs = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyMotorStator>(tmprs, b => ((IMyTerminalBlock)b).CustomName.Contains(RotorShoulderNameTag));
List<List<IMyTerminalBlock>> tmprss = sortByRelativePosition(tmprs, "X", true);
if (tmprss.Count >0) {
rotorShoulder.Add(tmprss[0][0]);
rotorShoulder.Add(tmprss[1][0]);
for(int i = 0; i < rotorShoulder.Count; i++) {
shoulderPIDList[i] = new PIDController(20f, 0.1f, 0f, 1f, -1f, 60);
}
}
}

GridTerminalSystem.GetBlocksOfType(LCD, b => ((IMyTerminalBlock)b).CustomName.Contains(DCSLCDNameTag));
if (Cockpit is IMyTextSurfaceProvider) {
var tmp =((IMyTextSurfaceProvider)Cockpit).GetSurface(2);
if (tmp != null) LCD.Add(tmp);
}

if(LCD.Count < 1)
{debugInfo = DCSLCDNameTag  + " not found";}

Gyroscopes = new List<IMyTerminalBlock>();
if(GyroscopesNameTag != "")
{
Gyroscopes = getBlockListByName(GyroscopesNameTag);
}
if(Gyroscopes.Count < 1)
{
GridTerminalSystem.GetBlocksOfType<IMyGyro> (Gyroscopes, b=>!b.CustomName.Contains(MISSILE_TAG));
FilterSameGrid(Me.CubeGrid, ref Gyroscopes);
}
if(Gyroscopes.Count < 1)
{
debugInfo = "No Gyro";
}

setupGyroField(Gyroscopes, ref gyroYawField, ref gyroYawFactor, ref gyroPitchField, ref gyroPitchFactor, ref gyroRollField, ref gyroRollFactor, Cockpit);
if (Head!=null)
  setupGyroField(Gyroscopes, ref gyroYawFieldHead, ref gyroYawFactorHead, ref gyroPitchFieldHead, ref gyroPitchFactorHead, ref gyroRollFieldHead, ref gyroRollFactorHead, Head);
SetGyroOverride(false);

findByGroup(liFcsSearchGroupName, liFcsSearchList);
findByGroup(liFcsLockGroupName, liFcsLockList);

fighterFcs = getBlockByName(fighterFcsName,false,true);
if (fighterFcs != null)
{
    String cmd = "REINIT:"+CockpitNameTag+","+LCDNameTag+","+ScanRange+","+homingTurretName+","+useTurretAsAimer+","+maxTargetCount;
    TerminalActionParameter tap = TerminalActionParameter.Deserialize(cmd, cmd.GetTypeCode());
    List<TerminalActionParameter> argumentList = new List<TerminalActionParameter>();
    argumentList.Add(tap);
    PlayAction(fighterFcs, "Run", argumentList);

}

InitSpeedControl();

GridTerminalSystem.GetBlocksOfType<IMySensorBlock> (sensors, b=>b.CubeGrid==Me.CubeGrid);

GridTerminalSystem.GetBlocksOfType<IMyCameraBlock> (cameraList,b=>b.CubeGrid==Me.CubeGrid);
cameraList.ForEach(delegate(IMyCameraBlock cam){cam.ApplyAction("OnOff_On");cam.EnableRaycast = true;});
findByGroup("LCD-Back-G",lcdBackList);

if (isBase && Cockpit.GetNaturalGravity().Length() > 0.01f){
downStartPos = Cockpit.GetPosition();
isDown = true;
}
init = true;
}

float MAX_GYRO_FACTOR = 60;

void setupGyroField(List<IMyTerminalBlock> Gyroscopes,
ref string[] gyroYawField,
ref float[] gyroYawFactor,
ref string[] gyroPitchField,
ref float[] gyroPitchFactor,
ref string[] gyroRollField,
ref float[] gyroRollFactor,
IMyShipController fc
) {
if(Gyroscopes.Count > 0)
{
gyroYawField = new string[Gyroscopes.Count];
gyroPitchField = new string[Gyroscopes.Count];
gyroYawFactor = new float[Gyroscopes.Count];
gyroPitchFactor = new float[Gyroscopes.Count];
gyroRollField = new string[Gyroscopes.Count];
gyroRollFactor = new float[Gyroscopes.Count];
for (int i = 0; i < Gyroscopes.Count; i++)
{
Base6Directions.Direction gyroUp = Gyroscopes[i].WorldMatrix.GetClosestDirection(fc.WorldMatrix.Up);
Base6Directions.Direction gyroLeft = Gyroscopes[i].WorldMatrix.GetClosestDirection(fc.WorldMatrix.Left);
Base6Directions.Direction gyroForward = Gyroscopes[i].WorldMatrix.GetClosestDirection(fc.WorldMatrix.Forward);

switch (gyroUp)
{
case Base6Directions.Direction.Up:
gyroYawField[i] = "Yaw";
gyroYawFactor[i] = GYRO_FACTOR;
break;
case Base6Directions.Direction.Down:
gyroYawField[i] = "Yaw";
gyroYawFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Left:
gyroYawField[i] = "Pitch";
gyroYawFactor[i] = GYRO_FACTOR;
break;
case Base6Directions.Direction.Right:
gyroYawField[i] = "Pitch";
gyroYawFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Forward:
gyroYawField[i] = "Roll";
gyroYawFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Backward:
gyroYawField[i] = "Roll";
gyroYawFactor[i] = GYRO_FACTOR;
break;
}

switch (gyroLeft)
{
case Base6Directions.Direction.Up:
gyroPitchField[i] = "Yaw";
gyroPitchFactor[i] = GYRO_FACTOR;
break;
case Base6Directions.Direction.Down:
gyroPitchField[i] = "Yaw";
gyroPitchFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Left:
gyroPitchField[i] = "Pitch";
gyroPitchFactor[i] = GYRO_FACTOR;
break;
case Base6Directions.Direction.Right:
gyroPitchField[i] = "Pitch";
gyroPitchFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Forward:
gyroPitchField[i] = "Roll";
gyroPitchFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Backward:
gyroPitchField[i] = "Roll";
gyroPitchFactor[i] = GYRO_FACTOR;
break;
}

switch (gyroForward)
{
case Base6Directions.Direction.Up:
gyroRollField[i] = "Yaw";
gyroRollFactor[i] = GYRO_FACTOR;
break;
case Base6Directions.Direction.Down:
gyroRollField[i] = "Yaw";
gyroRollFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Left:
gyroRollField[i] = "Pitch";
gyroRollFactor[i] = GYRO_FACTOR;
break;
case Base6Directions.Direction.Right:
gyroRollField[i] = "Pitch";
gyroRollFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Forward:
gyroRollField[i] = "Roll";
gyroRollFactor[i] = -GYRO_FACTOR;
break;
case Base6Directions.Direction.Backward:
gyroRollField[i] = "Roll";
gyroRollFactor[i] = GYRO_FACTOR;
break;
}
Gyroscopes[i].SetValue("Yaw", 0f);
Gyroscopes[i].SetValue("Pitch", 0f);
Gyroscopes[i].SetValue("Roll", 0f);
Gyroscopes[i].ApplyAction("OnOff_On");
}
}
}

List<List<IMyTerminalBlock>> sortByRelativePosition(List<IMyTerminalBlock> blocks, string dir, bool isAsc) {

  IEnumerable<IGrouping<int, IMyTerminalBlock>> grouped;

  switch (dir) {
  case "X":
    grouped = blocks.GroupBy(b=>(int)Math.Round((Vector3D.TransformNormal(b.GetPosition() - Cockpit.GetPosition(), refLookAtMatrix).X * 10 )));
  break;
  case "Y":
    grouped = blocks.GroupBy(b=>(int)Math.Round((Vector3D.TransformNormal(b.GetPosition() - Cockpit.GetPosition(), refLookAtMatrix).Y * 10 )));
  break;
  case "Z":
    grouped = blocks.GroupBy(b=>(int)Math.Round((Vector3D.TransformNormal(b.GetPosition() - Cockpit.GetPosition(), refLookAtMatrix).Z * 10 )));
  break;
  case "ZX":
    grouped = blocks.GroupBy(b=>((int)Math.Round((Vector3D.TransformNormal(b.GetPosition() - Cockpit.GetPosition(), refLookAtMatrix).Z * 10 ))) * 1000 + (int)Math.Round((Vector3D.TransformNormal(b.GetPosition() - Cockpit.GetPosition(), refLookAtMatrix).X * 10 )));
  break;
  default:
  return null;
  }

  if(isAsc)
    return grouped.OrderBy(g=>g.Key).Select(g=>g.ToList()).ToList();
  else
    return grouped.OrderByDescending(g=>g.Key).Select(g=>g.ToList()).ToList();
}


void callComputer(IMyTerminalBlock computer, string cmd) {
if (computer == null) return;
    TerminalActionParameter tap = TerminalActionParameter.Deserialize(cmd, cmd.GetTypeCode());
    List<TerminalActionParameter> argumentList = new List<TerminalActionParameter>();
    argumentList.Add(tap);
    PlayAction(computer, "Run", argumentList);

}

void SetGyroOverride(bool bOverride)
{
for (int i = 0; i < Gyroscopes.Count; i++)
{
if (((IMyGyro)Gyroscopes[i]).GyroOverride != bOverride)
{
Gyroscopes[i].ApplyAction("Override");
}
}
}

void SetGyroYaw(double yawRate)
{
if (legMode < 2) {
for (int i = 0; i < Gyroscopes.Count; i++)
{
Gyroscopes[i].SetValue(gyroYawField[i], (float)yawRate * gyroYawFactor[i]);
}
} else {
for (int i = 0; i < Gyroscopes.Count; i++)
{
Gyroscopes[i].SetValue(gyroYawFieldHead[i], (float)yawRate * gyroYawFactorHead[i]);
}
}
}

void SetGyroPitch(double pitchRate)
{
if (legMode < 2) {
for (int i = 0; i < Gyroscopes.Count; i++)
{
Gyroscopes[i].SetValue(gyroPitchField[i], (float)pitchRate * gyroPitchFactor[i]);
}
} else {
for (int i = 0; i < Gyroscopes.Count; i++)
{
Gyroscopes[i].SetValue(gyroPitchFieldHead[i], (float)pitchRate * gyroPitchFactorHead[i]);
}
}
}

void SetGyroRoll(double rollRate)
{
if (legMode < 2) {
for (int i = 0; i < Gyroscopes.Count; i++)
{
Gyroscopes[i].SetValue(gyroRollField[i], (float)rollRate * gyroRollFactor[i]);
}
} else {
for (int i = 0; i < Gyroscopes.Count; i++)
{
Gyroscopes[i].SetValue(gyroRollFieldHead[i], (float)rollRate * gyroRollFactorHead[i]);
}
}
}


// speed control start
List<IMyTerminalBlock> thrusters = null;
List<IMyTerminalBlock> forwardThrusters = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> leftThrusters = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> rightThrusters = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> upThrusters = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> downThrusters = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> backwardThrusters = new List<IMyTerminalBlock>();
IMyLargeTurretBase homingTurret = null;
Vector3D maintainSpeed = Vector3D.Zero;
Vector3D diffToMe;
MatrixD shipMatrix = MatrixD.Zero;
string debugInfo="";
string distanceInfo="";
int i = 0;

bool flyByOn=false;
string flyByOffsetDirection="LEFT";
double flyByDistance=100;
String motherCode=null;
String sonCode="RADAR";
double flyByForwardDistance=0;
double flyByUpDistance=0;
bool upMode=false;
double dockingForwardDistance=-100;
double dockingLeftDistance=0;
double dockingUpDistance=-100;
string dockingForward="FORWARD";
string dockingUp="UP";
bool dockingOn=false;
string dockingApproach="DOWN";
double dockingApproachDistance=50;
double dockingApproachDistanceLeft=50;
double dockingApproachDistanceUp=50;
double dockingApproachDistanceForward=50;
float dtp=0F;
bool isApproach=false;
string commandCache=null;
int commandStart=0;
int commandWaitTic=10;
int commandAllTic=100;

long pointDis = 1500;
bool motherPointerMode = false;
bool attackMode = false;

List<IMyTerminalBlock> connectors = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> landingGears = new List<IMyTerminalBlock>();
List<IMyTerminalBlock> spotlights = new List<IMyTerminalBlock>();



void GetThrusters() {
List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyThrust>(blocks, b=>!b.CustomName.Contains(MISSILE_TAG));
FilterSameGrid(Me.CubeGrid, ref blocks);
if (blocks.Count == 0) {
Echo("Warning: Missing Thrusters.");
}
thrusters = blocks;
MatrixD refWorldMatrix = Cockpit.WorldMatrix;
for (int i = 0; i < thrusters.Count; i++){
Base6Directions.Direction thrusterDirection = refWorldMatrix.GetClosestDirection(thrusters[i].WorldMatrix.Backward);
switch (thrusterDirection){
case Base6Directions.Direction.Forward:
forwardThrusters.Add(thrusters[i]);
break;
case Base6Directions.Direction.Left:
leftThrusters.Add(thrusters[i]);
break;
case Base6Directions.Direction.Right:
rightThrusters.Add(thrusters[i]);
break;
case Base6Directions.Direction.Up:
upThrusters.Add(thrusters[i]);
break;
case Base6Directions.Direction.Down:
downThrusters.Add(thrusters[i]);
break;
case Base6Directions.Direction.Backward:
backwardThrusters.Add(thrusters[i]);
break;
}
}
blocks = new List<IMyTerminalBlock>();

}

// 工具类
void setDampenersOverride(IMyTerminalBlock controller, bool onOff) {
bool nowOnOff = controller.GetValue<bool>("DampenersOverride");
if (nowOnOff != onOff) {
PlayAction(controller, "DampenersOverride");
}
}

void FilterSameGrid<T>(IMyCubeGrid grid, ref List<T> blocks) where T: class, IMyTerminalBlock
{
List<T> filtered = new List<T>();
for (int i = 0; i < blocks.Count; i++)
{
if (blocks[i].CubeGrid == grid && !blocks[i].CustomName.Contains("GE_"))
{
filtered.Add(blocks[i]);
}
}
if(filtered.Count == 0) return;
blocks = filtered;
}

void FilterSameName(String name, ref List<IMyTerminalBlock> blocks)
{
List<IMyTerminalBlock> filtered = new List<IMyTerminalBlock>();
for (int i = 0; i < blocks.Count; i++)
{
if (blocks[i].CustomName.Equals(name))
{
filtered.Add(blocks[i]);
}
}
if(filtered.Count == 0) return;
blocks = filtered;
}

public bool TestBoolValueForBlockList(List<IMyTerminalBlock> list, String name, bool value) {
for (var i=0;i<list.Count;i++){
if (name.Equals("IsConnected")) {
IMyShipConnector obj = (IMyShipConnector)list[i];
if (obj.Status.ToString().Equals("Connected")) return false;
}
if (name.Equals("IsLocked")) {
IMyLandingGear obj = (IMyLandingGear)list[i];
var builder = new StringBuilder();
obj.GetActionWithName("SwitchLock").WriteValue(obj, builder);

if (builder.ToString() == "Locked") return false;
}
}
return true;
}

public bool TestNotLocked() {
foreach ( IMyLandingGear obj in landingGears) {
var builder = new StringBuilder();
obj.GetActionWithName("SwitchLock").WriteValue(obj, builder);
if (builder.ToString().Equals("Locked")) return false;
}

return true;
}

public bool TestNotConnected(List<IMyTerminalBlock> list) {
for (var i=0;i<list.Count;i++){
IMyShipConnector obj = (IMyShipConnector)list[i];
if (obj.Status.ToString().Equals("Connected")) return false;
}
return true;
}


bool IsNotFriendly(MyDetectedEntityInfo FoundObjectInfo)
{
string ot = FoundObjectInfo.Type.ToString();
if (ot == "Planet" || ot == "Asteroid") return false;
var relationship = FoundObjectInfo.Relationship;
return (relationship != VRage.Game.MyRelationsBetweenPlayerAndBlock.FactionShare && relationship != VRage.Game.MyRelationsBetweenPlayerAndBlock.Owner);
}

public class CustomConfiguration
{
public IMyTerminalBlock configBlock;
public Dictionary<string, string> config;

public CustomConfiguration(IMyTerminalBlock block)
{
configBlock = block;
config = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
}

public void Load()
{
ParseCustomData(configBlock, config);
}

public void Save()
{
WriteCustomData(configBlock, config);
}

public string Get(string key, string defVal = null)
{
return config.GetValueOrDefault(key.Trim(), defVal);
}

public void Get(string key, ref string res)
{
string val;
if (config.TryGetValue(key.Trim(), out val))
{
res = val;
}
}

public void Get(string key, ref int res)
{
int val;
if (int.TryParse(Get(key), out val))
{
res = val;
}
}

public void Get(string key, ref float res)
{
float val;
if (float.TryParse(Get(key), out val))
{
res = val;
}
}

public void Get(string key, ref double res)
{
double val;
if (double.TryParse(Get(key), out val))
{
res = val;
}
}

public void Get(string key, ref bool res)
{
bool val;
if (bool.TryParse(Get(key), out val))
{
res = val;
}
}
public void Get(string key, ref bool? res)
{
bool val;
if (bool.TryParse(Get(key), out val))
{
res = val;
}
}

public void Set(string key, string value)
{
config[key.Trim()] = value;
}

public static void ParseCustomData(IMyTerminalBlock block, Dictionary<string, string> cfg, bool clr = true)
{
if (clr)
{
cfg.Clear();
}

string[] arr = block.CustomData.Split(new char[] {'\r','\n'}, StringSplitOptions.RemoveEmptyEntries);
for (int i = 0; i < arr.Length; i++)
{
string ln = arr[i];
string va;

int p = ln.IndexOf('=');
if (p > -1)
{
va = ln.Substring(p + 1);
ln = ln.Substring(0, p);
}
else
{
va = "";
}
cfg[ln.Trim()] = va.Trim();
}
}

public static void WriteCustomData(IMyTerminalBlock block, Dictionary<string, string> cfg)
{
StringBuilder sb = new StringBuilder(cfg.Count * 100);
foreach (KeyValuePair<string, string> va in cfg)
{
sb.Append(va.Key).Append('=').Append(va.Value).Append('\n');
}
block.CustomData = sb.ToString();
}
}
CustomConfiguration cfg;
void ProcessCustomConfiguration(){
cfg = new CustomConfiguration(Me);
cfg.Load();

cfg.Get("motherCode", ref motherCode);
cfg.Get("sonCode", ref sonCode);
cfg.Get("flyByOffsetDirection", ref flyByOffsetDirection);
cfg.Get("flyByDistance", ref flyByDistance);
cfg.Get("CockpitNameTag", ref CockpitNameTag);
cfg.Get("fighterFcsName", ref fighterFcsName);
cfg.Get("LCDNameTag", ref LCDNameTag);
cfg.Get("DCSLCDNameTag", ref DCSLCDNameTag);
cfg.Get("flyByForwardDistance", ref flyByForwardDistance);
cfg.Get("soundBlockNameTag", ref soundBlockNameTag);
cfg.Get("upMode", ref upMode);
cfg.Get("flyByUpDistance", ref flyByUpDistance);
cfg.Get("homingTurretName", ref homingTurretName);
cfg.Get("useTurretAsAimer", ref useTurretAsAimer);
cfg.Get("ScanRange", ref ScanRange);
cfg.Get("liFcsSearchGroupName", ref liFcsSearchGroupName);
cfg.Get("liFcsLockGroupName", ref liFcsLockGroupName);
cfg.Get("maxAV", ref maxAV);
cfg.Get("commandWaitTic", ref commandWaitTic);
cfg.Get("commandAllTic", ref commandAllTic);
cfg.Get("isBig", ref isBig);
cfg.Get("isDummy", ref isDummy);
cfg.Get("isBase", ref isBase);
cfg.Get("isME", ref isME);
cfg.Get("droneAttackRange", ref droneAttackRange);
cfg.Get("isPrinted", ref isPrinted);
cfg.Get("limitInnerRotor", ref limitInnerRotor);
cfg.Get("isAeroDynamic", ref isAeroDynamic);
cfg.Get("angleWhenDown", ref angleWhenDown);
cfg.Get("maxTargetCount", ref maxTargetCount);
cfg.Get("susMode", ref susMode);
// new para here

cfg.Get("dockingForwardDistance", ref dockingForwardDistance);
cfg.Get("dockingLeftDistance", ref dockingLeftDistance);
cfg.Get("dockingUpDistance", ref dockingUpDistance);
cfg.Get("dockingForward", ref dockingForward);
cfg.Get("dockingUp", ref dockingUp);
cfg.Get("dockingApproach", ref dockingApproach);
cfg.Get("dockingApproachDistance", ref dockingApproachDistance);
cfg.Get("dockingApproachDistanceLeft", ref dockingApproachDistanceLeft);
cfg.Get("dockingApproachDistanceUp", ref dockingApproachDistanceUp);
cfg.Get("dockingApproachDistanceForward", ref dockingApproachDistanceForward);
cfg.Get("shipWidth", ref shipWidth);
cfg.Get("shipHeight", ref shipHeight);
cfg.Get("shipLength", ref shipLength);
}

void InitSpeedControl() {
GetThrusters();

List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
homingTurret = getBlockByName(homingTurretName) as IMyLargeTurretBase;
if (homingTurret == null) {
GridTerminalSystem.GetBlocksOfType<IMyLargeTurretBase>(blocks);
FilterSameGrid(Me.CubeGrid, ref blocks);
homingTurret = (blocks.Count > 0 ? blocks[0] as IMyLargeTurretBase : null);
}

blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyShipConnector>(blocks);
FilterSameGrid(Me.CubeGrid, ref blocks);
connectors = blocks;

blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyReflectorLight>(blocks);
FilterSameGrid(Me.CubeGrid, ref blocks);
spotlights = blocks;

gcTargetPanel = getBlockByName(gcTargetPanelName, false, true) as IMyTextPanel;
for (int i = 0 ; i < maxTargetCount; i ++) {
var panel = getBlockByName(gcTargetPanelName+i, false, true);
if (panel == null) break;
gcTargetPanelList.Add(panel as IMyTextPanel);
}

rulerProjector = getBlockByName(rulerProjectorName, false);

}

void setRulerOnOff(bool onOff) {
if (onOff) {
PlayAction(rulerProjector, "OnOff_On");
rulerOn = true;
} else {
PlayAction(rulerProjector, "OnOff_Off");
rulerOn = false;
}
}

double thrusterPercentX = 0;
double thrusterPercentY = 0;
double thrusterPercentZ = 0;
double lastSpeedX = 0;
double lastSpeedY = 0;
double lastSpeedZ = 0;
double[,] accleHis = new double[3,10];
int[] accleHisIdx = new int[3]{0,0,0};
double[] twRate = new double[6]{0,0,0,0,0,0}; //rludbf
void SetBlocksValueFloat(List<IMyTerminalBlock> Blocks, string ValueName, float Value)
{
for(int i = 0; i < Blocks.Count; i ++)
{
Blocks[i].SetValueFloat(ValueName, Value);
}
}

string DimSpeed(double speed, List<IMyTerminalBlock> incThrusters, List<IMyTerminalBlock> decThrusters,
ref double dimPercent, double nowSpeed, double lastSpeed, bool isApprDir, double gravityDim, int dimIdx) {
string dr = "";

// limit thrusters when take off, otherwise they may burn the floor.
var tlimit = 1d;
if (flyByOn && isApproach ) {
if (speed > tlimit) speed = tlimit;
if (speed < - tlimit) speed = -tlimit;
}

// 求当前加速度
var nowA = (nowSpeed - lastSpeed) * 60;
var needA = (speed + nowSpeed - lastSpeed);

accleHis[dimIdx,accleHisIdx[dimIdx]] = needA;
accleHisIdx[dimIdx] = (accleHisIdx[dimIdx] + 1) % 10;

// 求目标加速度
var needAGra = needA - gravityDim;
dr += "needA: " + needAGra;
var needF = needAGra * shipMass;

float percent;

float maxAllFi = 0;
float maxAllFd = 0;
for (int i = 0; i < incThrusters.Count; i++) {
maxAllFi += ((IMyThrust)incThrusters[i]).MaxEffectiveThrust;
}
for (int i = 0; i < decThrusters.Count; i++) {
maxAllFd += ((IMyThrust)decThrusters[i]).MaxEffectiveThrust;
}


twRate[dimIdx*2] = maxAllFi / shipMass;
twRate[dimIdx*2 + 1] = maxAllFd / shipMass;

float maxAllF=0;
if (needF > 0) {
maxAllF = maxAllFi;
}else {
maxAllF = maxAllFd;
}

if (maxAllF == 0)percent = 0;
else percent = (float) needF / maxAllF;
dr+="\nPer: " + percent+" "+(incThrusters.Count+decThrusters.Count);
float zF = 0F;
 zF = 0.000001F;

if (percent == 0) {
for (int i = 0; i < incThrusters.Count; i++) {
((IMyThrust)incThrusters[i]).ThrustOverridePercentage = zF;
}
for (int i = 0; i < decThrusters.Count; i++) {
((IMyThrust)decThrusters[i]).ThrustOverridePercentage = zF;
}
} else if (percent > 0) {
for (int i = 0; i < incThrusters.Count; i++) {
((IMyThrust)incThrusters[i]).ThrustOverridePercentage = percent;
}
for (int i = 0; i < decThrusters.Count; i++) {
((IMyThrust)decThrusters[i]).ThrustOverridePercentage = zF;
}
} else {
for (int i = 0; i < incThrusters.Count; i++) {
((IMyThrust)incThrusters[i]).ThrustOverridePercentage = zF;
}
for (int i = 0; i < decThrusters.Count; i++) {
((IMyThrust)decThrusters[i]).ThrustOverridePercentage =  -percent;
}
}

return dr;
}

double maxTo(double src, double max) {
if(Math.Abs(src) > max) {
if (src > 0) {
return max;
} else {
return -max;
}
}else {
return src;
}
}

Vector3D calcSpeedToMeAndAvoid(Vector3D maintainSpeed) {
Vector3D myPosition = MePosition;
Vector3D needSpeedToMe = Vector3D.TransformNormal(maintainSpeed - MeVelocity, refLookAtMatrix);
Vector3D tmp = needSpeedToMe;
Vector3D apDiff;
double rate = 0.1;

if (flyByOn && !isApproach) {
long nKey = 0;
double nDis = 0;
int count = 0;
foreach(var item in avoidMap.ToList()) {
if (nKey == 0 || (item.Value - myPosition).Length() < nDis) {
nKey = item.Key;
nDis = (item.Value - myPosition).Length();
}
count ++;
}
if (count > 0) {
Vector3D thatPos = avoidMap[nKey];
apDiff = thatPos - myPosition;
if (apDiff.Length() < 50) {
Vector3D avoidSpeedToMe = Vector3D.TransformNormal(apDiff * rate * ((50-apDiff.Length())/apDiff.Length()), refLookAtMatrix);
needSpeedToMe -= avoidSpeedToMe;
}
}

double elevation = 0;
bool getted = Cockpit.TryGetPlanetElevation(MyPlanetElevation.Surface, out elevation);
if (getted) {
var naturalGravityNormal = Vector3D.Normalize(naturalGravity);
apDiff = naturalGravityNormal * elevation;
if (apDiff.Length() < 50) {
Vector3D avoidSpeedToMe = Vector3D.TransformNormal(apDiff * rate * ((50-apDiff.Length())/apDiff.Length()), refLookAtMatrix);
needSpeedToMe -= avoidSpeedToMe;
}
}

}

return needSpeedToMe;
}

void MaintainSpeed() {
RefreshMaintainSpeed();
if (!flyByOn && !dockingOn) return;
if(shipMatrix == MatrixD.Zero) return;
maintainSpeedToMeAA = calcSpeedToMeAndAvoid(maintainSpeed);
inputVec_RT=maintainSpeedToMeAA*1;//CODING
debugInfo += "t7" + displayVector3D(inputVec_RT) + "\n";

// 计算转向
isTurning = false;
double isTurningLimit = 0.1;
MatrixD refWorldMatrix = Cockpit.WorldMatrix;
Vector3D shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Forward, refLookAtMatrix));
MatrixD refLookAtMatrixUp = MatrixD.CreateLookAt(new Vector3D(0,0,0), refWorldMatrix.Up, refWorldMatrix.Backward);
Vector3D shipRollToMe = new Vector3D(0,0,0);
if (upMode) {
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Up, refLookAtMatrixUp));
} else {
switch(flyByOffsetDirection) {
case "LEFT":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Left, refLookAtMatrixUp));
break;
case "RIGHT":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Right, refLookAtMatrixUp));
break;
case "UP":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Up, refLookAtMatrixUp));
break;
case "DOWN":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Down, refLookAtMatrixUp));
break;
case "FORWARD":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Up, refLookAtMatrixUp));
break;
case "BACKWARD":
shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Backward, refLookAtMatrix));
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Up, refLookAtMatrixUp));
break;
}
}

if (flyByOn) {
if (!LockTargetPosition.Equals(Vector3D.Zero)) {
// do nothing
} else if (homingTurret!=null && homingTurret.HasTarget){
Vector3D direction;
Vector3D.CreateFromAzimuthAndElevation(homingTurret.Azimuth, homingTurret.Elevation, out direction);
Vector3D worldDirection = Vector3D.TransformNormal(direction, homingTurret.WorldMatrix);
Vector3D myDirection = Vector3D.TransformNormal(worldDirection, refLookAtMatrix);
SetGyroYaw(60 * AimRatio * myDirection.X);
SetGyroPitch(20 * AimRatio * myDirection.Y);
SetGyroOverride(true);
} else
{
Vector3D t2m = targetPosition - MePosition;
if (!isApproach) {
var sd = shipDirectionToMe;
if (needFlyByAim) {
Vector3D flyByAimPositionToMe = Vector3D.Normalize(Vector3D.TransformNormal(flyByAimPosition - MePosition, refLookAtMatrix));
sd = flyByAimPositionToMe;
} else if (t2m.Length() > 500 && t - lastNoHighSpeed > 600){
t2m = Vector3D.Normalize(t2m);
// 高差速指向
Vector3D d;
if (maintainSpeedToMeAA.Length() > 50) {
d = Vector3D.Normalize(maintainSpeedToMeAA);
} else {
if (t2m.Length() < 500) lastNoHighSpeed = t;
d = Vector3D.TransformNormal(t2m, refLookAtMatrix);
}
sd = d;
}
SetGyroYaw(AimRatio*sd.X*60);
if (isAeroDynamic && maintainSpeedToMeAA.Y > 0) {
var dy = (float)Math.Atan2(maintainSpeedToMeAA.Y, Math.Abs(maintainSpeedToMeAA.Z));
sd.Y += dy;
}
SetGyroPitch(AimRatio*sd.Y*20);
sd.Z=0;
if (sd.Length()>isTurningLimit) isTurning=true;


}

}

var naturalGravityNormal = Vector3D.Normalize(naturalGravity);
double sr = 0;
if (naturalGravityLength > 0) {
// VTOL roll adjust
var forward = Cockpit.WorldMatrix.Forward;
var left = Cockpit.WorldMatrix.Left;
var diff = diffGravity(left, naturalGravity, forward);

// use roll to get side speed in gravity
var sideRoll = maintainSpeedToMeAA.X * 0.01f; // radio
if (sideRoll > 0.5f) sideRoll = 0.5f;
if (sideRoll < -0.5f) sideRoll = -0.5f;
if (Math.Abs(sideRoll) < 0.05f) sideRoll = 0;
diff += sideRoll;
 if (Math.Abs(diff) > 0.0001f) { // death zone
sr = -1*diff*60;
 } else {
sr = -AimRatio*30*shipRollToMe.X;
}
} else {
sr = -AimRatio*30*shipRollToMe.X;
}
SetGyroRoll(sr);
if (sr > isTurningLimit) isTurning=true;
SetGyroOverride(true);
}


if(((flyByOn && isApproach) || dockingOn) && notDocked()) {
shipDirectionToMe = new Vector3D(0,0,0);
switch(dockingForward) {
case "LEFT":
shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Left, refLookAtMatrix));
break;
case "RIGHT":
shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Right, refLookAtMatrix));
break;
case "UP":
shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Up, refLookAtMatrix));
dtp=-0.5F;
break;
case "DOWN":
shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Down, refLookAtMatrix));
dtp=0.5F;
break;
case "FORWARD":
shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Forward, refLookAtMatrix));
break;
case "BACKWARD":
shipDirectionToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Backward, refLookAtMatrix));
break;
}

switch(dockingUp) {
case "LEFT":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Left, refLookAtMatrixUp));
break;
case "RIGHT":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Right, refLookAtMatrixUp));
break;
case "UP":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Up, refLookAtMatrixUp));
break;
case "DOWN":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Down, refLookAtMatrixUp));
break;
case "FORWARD":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Forward, refLookAtMatrixUp));
break;
case "BACKWARD":
shipRollToMe = Vector3D.Normalize(Vector3D.TransformNormal(shipMatrix.Backward, refLookAtMatrixUp));
break;
}

SetGyroYaw(AimRatio*30*shipDirectionToMe.X);
SetGyroPitch(AimRatio*10*shipDirectionToMe.Y);
SetGyroRoll(-AimRatio*30*shipRollToMe.X);
SetGyroOverride(true);

}

// 维持速度
if (flyByOn || (dockingOn && notDocked())) {
var dr= DimSpeedAll(maintainSpeedToMeAA,refLookAtMatrix);
}

}

string DimSpeedAll(Vector3D maintainSpeedToMe, MatrixD refLookAtMatrix) {
//
string dr = "";
Vector3D nowSpeedToMe = Vector3D.TransformNormal(Cockpit.GetShipVelocities().LinearVelocity, refLookAtMatrix);
var nrl = msc.WorldMatrix.Right.Dot(naturalGravity);
var nud = msc.WorldMatrix.Up.Dot(naturalGravity);
if(isME) nud = 0; //CODING
var nbf = msc.WorldMatrix.Backward.Dot(naturalGravity);

List<IMyTerminalBlock> upThrustersIfHead = upThrusters;
List<IMyTerminalBlock> downThrustersIfHead = downThrusters;
List<IMyTerminalBlock> forwardThrustersIfHead = forwardThrusters;
List<IMyTerminalBlock> backwardThrustersIfHead = backwardThrusters;

if (legMode > 1) {
upThrustersIfHead = backwardThrusters;
downThrustersIfHead = forwardThrusters;
forwardThrustersIfHead = upThrusters;
backwardThrustersIfHead = downThrusters;
}

if (legMode == 3) {
return "";
}
DimSpeed(maintainSpeedToMe.X, rightThrusters, leftThrusters, ref thrusterPercentX, nowSpeedToMe.X, lastSpeedX, "LEFT".Equals(dockingApproach)||"RIGHT".Equals(dockingApproach), nrl,0);
lastSpeedX = nowSpeedToMe.X;
dr = DimSpeed(maintainSpeedToMe.Y, upThrustersIfHead, downThrustersIfHead, ref thrusterPercentY, nowSpeedToMe.Y, lastSpeedY, "UP".Equals(dockingApproach)||"DOWN".Equals(dockingApproach), nud,1);
lastSpeedY = nowSpeedToMe.Y;
DimSpeed(maintainSpeedToMe.Z, backwardThrustersIfHead, forwardThrustersIfHead, ref thrusterPercentZ, nowSpeedToMe.Z, lastSpeedZ, "FORWARD".Equals(dockingApproach)||"BACKWARD".Equals(dockingApproach), nbf,2);
lastSpeedZ = nowSpeedToMe.Z;
return dr;
}

bool notDocked() {
bool isNotLocked = true;
isNotLocked = TestBoolValueForBlockList(landingGears, "IsLocked", false);
if (!isNotLocked) return false;
isNotLocked = TestBoolValueForBlockList(connectors, "IsConnected", false);
if (!isNotLocked) return false;
return true;
}

bool dockable() {
foreach ( IMyShipConnector obj in connectors) {
if (! obj.Status.ToString().Equals("Connectable")
&& !obj.Status.ToString().Equals("Connected"))
return false;
}
foreach ( IMyLandingGear obj in landingGears) {
var builder = new StringBuilder();
obj.GetActionWithName("SwitchLock").WriteValue(obj, builder);
if (!builder.ToString().Equals("Ready To Lock")
&& !builder.ToString().Equals("Locked"))
return false;
}
if (landingGears.Count == 0) return false;
return true;
}

void startFlyBy() {
dockingOn=false;
attackMode=false;
setDampenersOverride(Cockpit, false);
PlayActionList(thrusters, "OnOff_On");
for (int i = 0; i < offGridThrust.Count; i++) {
offGridThrust[i].Enabled=true;
}
PlayActionList(landingGears, "Unlock");
PlayActionList(landingGears, "OnOff_Off");
PlayActionList(connectors, "Unlock");
PlayActionList(connectors, "OnOff_Off");
PlayActionList(spotlights, "OnOff_On");
flyByOn = true;
callComputer(fighterFcs, "ALLON");
}

void startDocking(){
attackMode=false;
setDampenersOverride(Cockpit, false);
PlayActionList(thrusters, "OnOff_On");
for (int i = 0; i < offGridThrust.Count; i++) {
offGridThrust[i].Enabled=true;
}
PlayActionList(connectors, "OnOff_On");
PlayActionList(landingGears, "OnOff_On");
flyByOn = false;
callComputer(fighterFcs, "ALLOFF");
dockingOn = true;
}

Dictionary<long, Vector3D> avoidMap = new Dictionary<long, Vector3D>();
Dictionary<long, long> avoidLifeTimeMap = new Dictionary<long, long>();

void ParseSensor() {
MyDetectedEntityInfo mdei = new MyDetectedEntityInfo();
foreach(var sensor in sensors) {
var tmp = sensor.LastDetectedEntity;
if (tmp.EntityId!=0) mdei = tmp;
}
if (mdei.EntityId == 0) return;
MatrixD refWorldMatrix = mdei.Orientation;
Vector3D currentPos = mdei.Position;
Vector3D speed = mdei.Velocity;
Vector3D myPosition = MePosition;

string message = sonCode + ":" + refWorldMatrix.M11+","+refWorldMatrix.M12+","+refWorldMatrix.M13+","+refWorldMatrix.M14+","+
refWorldMatrix.M21+","+refWorldMatrix.M22+","+refWorldMatrix.M23+","+refWorldMatrix.M24+","+
refWorldMatrix.M31+","+refWorldMatrix.M32+","+refWorldMatrix.M33+","+refWorldMatrix.M34+","+
currentPos.X+","+currentPos.Y+","+currentPos.Z+","+refWorldMatrix.M44+","+
speed.X+","+speed.Y+","+speed.Z;

ParseMaintainSpeed(message);

}

int adm = 20;

void ParseMaintainSpeed(string arguments) {
String[] kv = arguments.Split(':');
String[] args;

if (kv[0].Equals(sonCode+"-AVOID")) {
args=kv[1].Split(',');
avoidMap[Convert.ToInt64(args[0])] = new Vector3D(Convert.ToDouble(args[1]), Convert.ToDouble(args[2]), Convert.ToDouble(args[3]));
avoidLifeTimeMap[Convert.ToInt64(args[0])] = t;
}

foreach(var item in avoidLifeTimeMap.ToList()) {
if (t > item.Value + 120) {
avoidMap.Remove(item.Key);
avoidLifeTimeMap.Remove(item.Key);
}
}

if (! kv[0].Equals(sonCode)) return;

args = kv[1].Split(',');
List<IMyTerminalBlock> welderList;
switch(args[0]) {
case "FLYBYON":
if (sonCode == null || shipPosition==Vector3D.Zero) break;
commandCache="FLYBYON";
commandStart=t;
break;
case "DOCKINGON":
if (sonCode == null) break;
commandCache="DOCKINGON";
commandStart=t;
break;
case ("LOADMISSILEON"):
if (sonCode == null) break;
welderList = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyShipWelder> (welderList);
PlayActionList(welderList, "OnOff_On");
break;
case ("FIREMISSILEON"):
if (sonCode == null) break;
fireMissile();
break;
case "DETRANSON":
if (sonCode == null) break;
PlayActionList(connectors, "Unlock");
PlayActionList(connectors, "OnOff_Off");
PlayActionList(landingGears, "OnOff_On");
PlayActionList(landingGears, "Lock");
break;
case "TRANSON":
if (sonCode == null) break;
PlayActionList(connectors, "OnOff_On");
PlayActionList(connectors, "Lock");
PlayActionList(landingGears, "Unlock");
PlayActionList(landingGears, "OnOff_Off");
break;
case "ATTACKON":
if (sonCode == null) break;
if (flyByOn) {
attackMode=true;
}
break;
case "ATTACKOFF":
if (sonCode == null) break;
if (flyByOn) {
attackMode=false;
}
break;
case "WEAPON1":
if (sonCode == null) break;
callComputer(fighterFcs,"WEAPON1");
break;
case "WEAPON2":
if (sonCode == null) break;
callComputer(fighterFcs,"WEAPON2");
break;
default:
break;
}

if(args.Count() < 19) return;

lastMotherSignalTime = t;
shipMatrix = new MatrixD(Convert.ToDouble(args[0]),Convert.ToDouble(args[1]),Convert.ToDouble(args[2]),Convert.ToDouble(args[3]),
Convert.ToDouble(args[4]),Convert.ToDouble(args[5]),Convert.ToDouble(args[6]),Convert.ToDouble(args[7]),
Convert.ToDouble(args[8]),Convert.ToDouble(args[9]),Convert.ToDouble(args[10]),Convert.ToDouble(args[11]),
Convert.ToDouble(args[12]),Convert.ToDouble(args[13]),Convert.ToDouble(args[14]),Convert.ToDouble(args[15]));

shipPosition = new Vector3D(shipMatrix.M41, shipMatrix.M42, shipMatrix.M43);

MatrixD shipLookAtMatrix = MatrixD.CreateLookAt(new Vector3D(0,0,0), shipMatrix.Forward, shipMatrix.Up);

shipSpeed = new Vector3D(Convert.ToDouble(args[16]), Convert.ToDouble(args[17]), Convert.ToDouble(args[18]));
needFlyByAim = false;
if (susMode) {
flyByAimPosition = shipPosition;
flyByAimSpeed = Vector3D.Zero;
needFlyByAim = true;
}
if (args.Count() >= 25) {
flyByAimPosition = new Vector3D(Convert.ToDouble(args[19]),Convert.ToDouble(args[20]),Convert.ToDouble(args[21]));
flyByAimSpeed = new Vector3D(Convert.ToDouble(args[22]),Convert.ToDouble(args[23]),Convert.ToDouble(args[24]));
needFlyByAim = true;
callComputer(fighterFcs, "FLYBYAIM:"+flyByAimPosition.X+","+flyByAimPosition.Y+","+flyByAimPosition.Z);

if (args.Count() >=26) {
Vector3D dir = flyByAimPosition - shipPosition;
dir = Vector3D.Normalize(dir);
if (!isBig) {
double standardAttackAngle = Convert.ToDouble(args[25]);
MatrixD aimMatrix;
if (naturalGravityLength > 0.01f) {
  dir = naturalGravity;
  aimMatrix = MatrixD.CreateFromDir(Vector3D.Normalize(naturalGravity), shipMatrix.Forward);
} else {
  aimMatrix = MatrixD.CreateFromDir(dir, shipMatrix.Up);
}

var angle = standardAttackAngle + (commandWaitTic * 1d / commandAllTic) * MathHelper.TwoPi;
Vector3D upBaseAim = new Vector3D(Math.Cos(angle),Math.Sin(angle),0);
Vector3D up=Vector3D.TransformNormal(upBaseAim,aimMatrix);
var ad = t%600/600f*adm;
flyByAttackPosition = flyByAimPosition + 800*up - (droneAttackRange + ad)*dir;
var tp2m = flyByAimPosition - MePosition;
var tp2mn = Vector3D.Normalize(tp2m);
var fp2m = flyByAttackPosition - MePosition;
var fp2ml = fp2m.Dot(tp2mn);
if (fp2ml > tp2m.Length()) {
var nap2m = tp2m * (tp2m.Length()-800)/tp2m.Length();
flyByAttackPosition = MePosition + nap2m;
}
}else{
Vector3D tmp = Vector3D.Reject(dir, shipMatrix.Up);
if (tmp.Equals(Vector3D.Zero)) {
tmp = shipMatrix.Forward;
}else {
tmp = Vector3D.Normalize(tmp);
}
MatrixD rd = MatrixD.CreateFromDir(tmp, shipMatrix.Up);

Vector3D off;

switch(flyByOffsetDirection) {
case "LEFT":
off = rd.Left;
break;
case "RIGHT":
off = rd.Right;
break;
default:
off = rd.Up;
break;
}

flyByAttackPosition = flyByAimPosition + 1500*off - 100*dir;

}
}

}
if (needFlyByAim == false && radarHighThreatPosition!=Vector3D.Zero) {
flyByAimPosition = radarHighThreatPosition;
needFlyByAim = true;
}
}

void RefreshMaintainSpeed(){
// 计算速度
if(shipMatrix == MatrixD.Zero) return;
shipPosition = new Vector3D(shipMatrix.M41, shipMatrix.M42, shipMatrix.M43);
MatrixD shipLookAtMatrix = MatrixD.CreateLookAt(new Vector3D(0,0,0), shipMatrix.Forward, shipMatrix.Up);


Vector3D myPosition = MePosition;
Vector3D myToShipPosition = MePosition - shipPosition;
myToShipPosition = Vector3D.TransformNormal(myToShipPosition, shipLookAtMatrix);
distanceInfo=displayVector3D(myToShipPosition);
targetPosition = calcApproach(myToShipPosition, shipPosition, ref isApproach);

if (flyByOn) {
if (!isApproach) {

switch(flyByOffsetDirection) {
case "LEFT":
targetPosition = shipPosition + shipMatrix.Left * flyByDistance + shipMatrix.Forward * flyByForwardDistance + shipMatrix.Up * flyByUpDistance;
break;
case "RIGHT":
targetPosition = shipPosition + shipMatrix.Right * flyByDistance + shipMatrix.Forward * flyByForwardDistance + shipMatrix.Up * flyByUpDistance;
break;
case "UP":
targetPosition = shipPosition + shipMatrix.Up * flyByDistance + shipMatrix.Forward * flyByForwardDistance + shipMatrix.Up * flyByUpDistance;
break;
case "DOWN":
targetPosition = shipPosition + shipMatrix.Down * flyByDistance + shipMatrix.Forward * flyByForwardDistance + shipMatrix.Up * flyByUpDistance;
break;
case "FORWARD":
targetPosition = shipPosition + shipMatrix.Forward * flyByDistance + shipMatrix.Up * flyByUpDistance;
break;
case "BACKWARD":
targetPosition = shipPosition + shipMatrix.Backward * flyByDistance + shipMatrix.Up * flyByUpDistance;
break;
}

}
}

if (dockingOn) {
if (isApproach) {
targetPosition = shipPosition + shipMatrix.Forward * dockingForwardDistance + shipMatrix.Left * dockingLeftDistance + shipMatrix.Up * dockingUpDistance;
// to maintain some speed when docking, modify the target position deeper.
double diffStop = 0.1d;
switch(dockingApproach) {
case "LEFT":
targetPosition -= shipMatrix.Left * diffStop;
break;
case "RIGHT":
targetPosition -= shipMatrix.Right * diffStop;
break;
case "UP":
targetPosition -= shipMatrix.Up * diffStop;
break;
case "DOWN":
targetPosition -= shipMatrix.Down * diffStop;
break;
case "FORWARD":
targetPosition -= shipMatrix.Forward * diffStop;
break;
case "BACKWARD":
targetPosition -= shipMatrix.Backward * diffStop;
break;
}
}
}

if (attackMode) {
targetPosition = flyByAttackPosition;
}

Vector3D diffPosition = targetPosition - myPosition;

if (attackMode) {
shipSpeed = flyByAimSpeed;
}

bool isClose = Math.Abs(myToShipPosition.X) < shipWidth && Math.Abs(myToShipPosition.Y) < shipHeight && Math.Abs(myToShipPosition.Z) < shipLength && (!isApproach);
Vector3D shipSpeedBaseShip = Vector3D.TransformNormal(shipSpeed, shipLookAtMatrix);
Vector3D diffPositionBaseShip =  Vector3D.TransformNormal(targetPosition - myPosition, shipLookAtMatrix);

if (isClose) {
Vector3D m2s = myPosition - shipPosition;
m2s = Vector3D.TransformNormal(m2s, shipLookAtMatrix);
m2s = new Vector3D(m2s.X / shipWidth, m2s.Y / shipHeight, m2s.Z / shipLength);
m2s = Vector3D.TransformNormal(m2s, shipMatrix);
Base6Directions.Direction myToShipDir = shipMatrix.GetClosestDirection(m2s);

switch (myToShipDir)
{
case Base6Directions.Direction.Forward:
diffPositionBaseShip.Z = Math.Min(diffPositionBaseShip.Z, 0);
break;
case Base6Directions.Direction.Backward:
diffPositionBaseShip.Z = Math.Max(diffPositionBaseShip.Z, 0);
break;
case Base6Directions.Direction.Left:
diffPositionBaseShip.X = Math.Min(diffPositionBaseShip.X, 0);
break;
case Base6Directions.Direction.Right:
diffPositionBaseShip.X = Math.Max(diffPositionBaseShip.X, 0);
break;
case Base6Directions.Direction.Down:
diffPositionBaseShip.Y = Math.Min(diffPositionBaseShip.Y, 0);
break;
case Base6Directions.Direction.Up:
diffPositionBaseShip.Y = Math.Max(diffPositionBaseShip.Y, 0);
break;
}

} else {
}

// 根据6向推重比（8成），算减速距离，超过减速距离就一直加速，直到触发速度限制（配合计算伴飞朝向时，在距离远时使子船头指向需要加速的方向）
Vector3D absDiff = Vector3D.TransformNormal(diffPositionBaseShip, shipMatrix);
diffToMe = Vector3D.TransformNormal(absDiff, refLookAtMatrix);
Vector3D shipSpeedToMe = Vector3D.TransformNormal(shipSpeed, refLookAtMatrix);
double speedLimit = 800;
if (isBig) speedLimit = 80;
double avaSpeed = speedLimit;
double[] tstmA = new double[3]{0,0,0};
for(int dimIdx = 0; dimIdx < 3; dimIdx++) {
// 遍历3个维度
double dimDiff=0;
double dimSpeedDiff = 0;
double dimSpeed=0;
if (dimIdx == 0) {
dimDiff = diffToMe.X;
dimSpeed = mySpeedToMe.X;
dimSpeedDiff = mySpeedToMe.X - shipSpeedToMe.X;
}else if (dimIdx == 1) {
dimDiff = diffToMe.Y;
dimSpeed = mySpeedToMe.Y;
dimSpeedDiff = mySpeedToMe.Y - shipSpeedToMe.Y;
} else {
dimDiff = diffToMe.Z;
dimSpeed = mySpeedToMe.Z;
dimSpeedDiff = mySpeedToMe.Z - shipSpeedToMe.Z ;
}
double tw = 0;
if (dimDiff < 0) tw = twRate[dimIdx*2];
else tw = twRate[dimIdx*2+1];
tw = tw * 0.8;

double diffTime = Math.Abs(dimSpeedDiff / tw);
double decMinDis = dimSpeedDiff * diffTime * 0.5;
float slideRatio = 1f;
double targetSpeedDiff=0;
double nearRange = 500;
if (Math.Abs(dimDiff) < nearRange || isTurning) {
targetSpeedDiff = dimDiff * 0.025 - dimSpeedDiff;
} else if (Math.Abs(dimDiff) > Math.Abs(decMinDis) * slideRatio + nearRange ) {
// 单向距离足够减速，单向加速
targetSpeedDiff = dimSpeedDiff + dimDiff;
double dimSpeedLimit = 0;
dimSpeedLimit = avaSpeed;
if (Math.Abs(dimSpeed) > dimSpeedLimit) {
// 最高dimSpeedLimit接近
targetSpeedDiff = 0;
}
}else if (Math.Abs(dimDiff) < Math.Abs(decMinDis) + nearRange){
// 单向距离不够减速，进入减速周期, 全力减速
targetSpeedDiff = -dimSpeedDiff * 10;
}
tstmA[dimIdx] = targetSpeedDiff;
}

Vector3D aSpeed ;
if (!dockingOn && !isApproach){
aSpeed = new Vector3D(tstmA[0],tstmA[1],tstmA[2]);
MatrixD refWorldMatrix = Cockpit.WorldMatrix;
aSpeed = Vector3D.TransformNormal(aSpeed, refWorldMatrix);
maintainSpeed = MeVelocity + aSpeed;
} else {
aSpeed = new Vector3D(adjustSpeed(diffPositionBaseShip.X), adjustSpeed(diffPositionBaseShip.Y), adjustSpeed(diffPositionBaseShip.Z));
Vector3D mSpeedBaseShip = shipSpeedBaseShip + aSpeed;
maintainSpeed = Vector3D.TransformNormal(mSpeedBaseShip, shipMatrix);
}

}

string displayVector3D(Vector3D tar) {
return Math.Round(tar.X, 2) + ", " + Math.Round(tar.Y, 2) + ", " + Math.Round(tar.Z, 2);
}
string displayDouble(double tar) {
return ""+Math.Round(tar, 2);
}

double adjustSpeed(double distance) {
var speed = distance;
double abs = Math.Abs(speed);
double ret = 0;
double limit = 100;
if (attackMode) limit = 500;
if (abs > limit) ret = limit /5;
else ret = abs / 5;

// if (isApproach && Math.Abs(distance) < 10) {
// if(distance>=0) return 5;
// else return -5;
// }

if (speed > 0) return ret;
else return -ret;
}

Vector3D calcApproach(Vector3D myToShipPosition, Vector3D shipPosition, ref bool isApproach) {
MatrixD refWorldMatrix = Cockpit.WorldMatrix;
MatrixD shipLookAtMatrix = MatrixD.CreateLookAt(new Vector3D(0,0,0), shipMatrix.Forward, shipMatrix.Up);
Vector3D tp = new Vector3D(0,0,0);
float delta = 2f;
Vector3D approachPos = shipPosition + shipMatrix.Forward * dockingApproachDistanceForward + shipMatrix.Left * dockingApproachDistanceLeft + shipMatrix.Up * dockingApproachDistanceUp;
Vector3D apToShip = Vector3D.TransformNormal(approachPos - shipPosition,shipLookAtMatrix);

if (flyByOn) {
if (isApproach == false) return tp;
if ((myToShipPosition - apToShip).Length() < delta*10) {
isApproach = false;
return tp;
} else {
return approachPos;
}
}

if(dockingOn) {
if (isApproach == true) return tp;
if ((myToShipPosition - apToShip).Length() < delta) {
isApproach = true;
return tp;
} else {
return approachPos;
}
}
return tp;
}

void findByGroup(string groupName, List<IMyTerminalBlock> blocks) {
var group = GridTerminalSystem.GetBlockGroupWithName(groupName);
if (group == null) return;
group.GetBlocks(blocks);
}

void fireMissile(){
if(t < msBuildStart + msBuildInterval) {
return;
}

List<IMyTerminalBlock> welderList = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyShipWelder> (welderList);

List<IMyTerminalBlock> msMergeList = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyShipMergeBlock> (msMergeList, b => b.CustomName.Contains("#A#"));
if (msMergeList.Count == 0) {
PlayActionList(welderList, "OnOff_On");
msBuildStart = t;
return;
}

PlayActionList(welderList, "OnOff_Off");
List<IMyTerminalBlock> timerList = new List<IMyTerminalBlock>();
GridTerminalSystem.SearchBlocksOfName("Timer Block Miss", timerList);
PlayActionList(timerList, "TriggerNow");
}


/*
/// Whip's Rotor Thruster Manager v29 - 11/22/17 ///

Author's Notes

I hope y'all enjoy this code. I hope it makes VTOL and vector thrust craft more feasible :)

- Whiplash141
*/

//-----------------------------------------------
//         CONFIGURABLE VARIABLES
//-----------------------------------------------

const string controlSeatNameTag = "Reference";

const string ignoredThrustNameTag = "RCS";

bool ignoreThrustersOnConnectors = true;

bool turnOnRotorThrustersWhenDisabled = false;

bool useRotorThrustAsInertialDampeners = true;

const double dampenerScalingFactor = 50;

const double fullBurnToleranceAngle = 5;

const double minDampeningAngle = 75;

bool referenceIsOnSameGridAsProgram = true; //recommended setting: true
Vector3D thrustNeed = Vector3D.Zero;

//-----------------------------------------------
//         No touching below this line
//-----------------------------------------------
const double updatesPerSecond = 10;
//Number of updates per second
const double timeMaxCycle = 1 / updatesPerSecond;
double timeCurrentCycle = 0;
const double refreshInterval = 10;
double refreshTime = 141;
bool isSetup = false;


List<IMyShipController> referenceList = new List<IMyShipController>();
List<IMyThrust> offGridThrust = new List<IMyThrust>();
List<IMyThrust> onGridThrust = new List<IMyThrust>();

IMyShipController thisReferenceBlock = null;
Vector3D lastSpeedVector = new Vector3D(0,0,0);

double maxThrustDotProduct ;
double minDampeningDotProduct ;
double fullBurnDotProduct ;

void Main_RT(string argument, UpdateType updateType)
{
double maxThrustAngle = 10;
if (naturalGravityLength > 0.01) maxThrustAngle = 55;//coding
maxThrustDotProduct = Math.Cos(maxThrustAngle * Math.PI / 180);
minDampeningDotProduct = Math.Cos(minDampeningAngle * Math.PI / 180);
fullBurnDotProduct = Math.Cos(fullBurnToleranceAngle * Math.PI / 180);


//if ((updateType & UpdateType.Update1) == 0) //only runs bulk of logic when triggered by itself
//return;

timeCurrentCycle += 1.0/60.0;
refreshTime += 1.0/60.0;

if (!isSetup )
{
GrabBlocks();
isSetup = true;
refreshTime = 0;
}

if (!isSetup)
return;

//if (timeCurrentCycle >= timeMaxCycle) 
if (true) 
{
try
{
// Echo status:
Echo("DCS v4-vf");
Echo(debugInfo);
if(Head != null) {
Echo("Head: " + Head.CustomName + "\n");
}
Echo("WMI Rotor Thruster\nManager... " + RunningSymbol() + "\n");

thisReferenceBlock = GetControlledShipController(referenceList);
Echo($"Gyros :{Gyroscopes.Count}");
Echo($"Off-Grid Thrusters: {offGridThrust.Count}");

var shipSpeed = thisReferenceBlock.GetShipSpeed();

debugInfo += "t8" + displayVector3D(inputVec_RT) + "\n";
if(true){
if(inputVec_RT.Length() < 0.1 && aeroSpeedLevel>0){
if(mySpeedToMe.Z > (-10*aeroSpeedLevel)){
inputVec_RT.Z = MathHelper.Clamp( ft, -1, 1);
}
}
}

if(Math.Abs(inputVec_RT.Z)>0.2) {
if(inputVec_RT.Z>0){
inputVec_RT.Z-=0.2;
}else{
inputVec_RT.Z+=0.2;
}
} else {
inputVec_RT.Z=0;
}

if(notDocked()) {
// CODING TN
Vector3D needA = inputVec_RT * 10.0; // 1G
if ((flyByOn||dockingOn) && maintainSpeedToMeAA.Length()>0) {
var ms = maintainSpeedToMeAA;
if (ms.Length() > 10f) {
ms *= 10f/ms.Length();
}
needA += ms * 1.0;
}

Vector3D mstm = mySpeedToMe;
if (dampenersOn) {
Vector3D mstmn = mstm;
if (mstm.Length() > 1) mstmn = mstm * (1f/mstm.Length());
mstmn *= -10;
var needAN = Vector3D.Zero;
if(Math.Abs(inputVec.Length()) > 0.1) {
var inin = Vector3D.Normalize(inputVec);
mstmn = Vector3D.Reject(mstmn, inin);
}
if (aeroSpeedLevel>0 ) {
mstmn.Z = 0;
}
needA += mstmn; 
}
var ngtome = Vector3D.TransformNormal(naturalGravity, refLookAtMatrix);
needA -= ngtome;
var desiredDirectionVec = Vector3D.TransformNormal(needA, msc.WorldMatrix);

var mass = msc.CalculateShipMass().PhysicalMass;
thrustNeed = mass * desiredDirectionVec;
double maxThrust = 0;
foreach (var block in onGridThrust)
{
var dir = -block.WorldMatrix.Forward;

thrustNeed -= dir * block.CurrentThrust;
if (block.CurrentThrust > maxThrust) maxThrust = block.CurrentThrust;
}
thrustNeed = Vector3D.Reject(thrustNeed, msc.WorldMatrix.Left);
if(isDown || isApproach){
thrustNeed = Vector3D.Reject(thrustNeed, msc.WorldMatrix.Forward);
}
double thrustMax = 0;
var thrustNeedDir = Vector3D.Normalize(thrustNeed);
foreach (IMyThrust thisThrust in offGridThrust)
{
var thrustDirection = thisThrust.WorldMatrix.Forward;
float scale = -(float)thrustDirection.Dot(thrustNeedDir);
if (scale > maxThrustDotProduct)
{
thrustMax += thisThrust.MaxEffectiveThrust;
}

}
if (thrustMax == 0) thrustMax = 1;
var percent = (float)MathHelper.Clamp(thrustNeed.Length() / thrustMax, 0, 1);
foreach (IMyThrust thisThrust in offGridThrust)
{
var thrustDirection = thisThrust.WorldMatrix.Forward;
float scale = -(float)thrustDirection.Dot(thrustNeedDir);
if (scale > maxThrustDotProduct)
{
SetThrusterOverride(thisThrust, (float)percent * scale);
}else {
SetThrusterOverride(thisThrust, 0f);
}//CODING

}

// END CODING
} else {
foreach (IMyThrust thisThrust in offGridThrust) {
SetThrusterOverride(thisThrust, 0f);
}
}

string dampenerStatus = dampenersOn ? "Enabled" : "Disabled";

Echo($"Dampeners: {dampenerStatus}");


timeCurrentCycle = 0;
}
catch
{
//isSetup = false;
}
}
}

float tcrtLimit = 0.01f;// dimspeed takecontrol rt limit

bool GrabBlocks()
{
if (referenceIsOnSameGridAsProgram)
GridTerminalSystem.GetBlocksOfType(referenceList, block => block.CustomName.ToLower().Contains(controlSeatNameTag.ToLower()));
else
GridTerminalSystem.GetBlocksOfType(referenceList, block => block.CustomName.ToLower().Contains(controlSeatNameTag.ToLower()));

if (referenceList.Count == 0)
{
Echo($"[ERROR]: No remote or control seat with name tag '{controlSeatNameTag}' was found");
return false;
}

if (!ignoreThrustersOnConnectors)
{
GridTerminalSystem.GetBlocksOfType(offGridThrust, block => block.CubeGrid != referenceList[0].CubeGrid && !block.CustomName.ToLower().Contains(ignoredThrustNameTag.ToLower()));
}
else
{
var connectors = new List<IMyShipConnector>();
var connectorGrids = new List<IMyCubeGrid>();
GridTerminalSystem.GetBlocksOfType(connectors, block => block.CubeGrid != referenceList[0].CubeGrid);

foreach (IMyShipConnector thisConnector in connectors)
{
connectorGrids.Add(thisConnector.CubeGrid);
}

GridTerminalSystem.GetBlocksOfType(offGridThrust, block => block.CubeGrid != referenceList[0].CubeGrid && !connectorGrids.Contains(block.CubeGrid) && !block.CustomName.ToLower().Contains(ignoredThrustNameTag.ToLower()));
}

if (offGridThrust.Count == 0)
{
Echo("[ERROR]: No off grid thrusters found");
return false;
}

GridTerminalSystem.GetBlocksOfType(onGridThrust, block => block.CubeGrid == referenceList[0].CubeGrid);
if (onGridThrust.Count == 0)
{
Echo("[INFO]: No on grid thrusters found");
}

return true;
}

IMyShipController GetControlledShipController(List<IMyShipController> SCs)
{
foreach (IMyShipController thisController in SCs)
{
if (thisController.IsUnderControl && thisController.CanControlShip)
return thisController;
}

return SCs[0];
}

void SetThrusterOverride(IMyThrust thruster, float percent)
{
IMyThrust t = thruster;
if(percent < 0) percent = 0;
if(percent>0){
t.ThrustOverridePercentage = percent;
} else {

t.ThrustOverridePercentage = 0.000001f;

}
t.Enabled = true;
}
void SetThrusterListOverride(List<IMyTerminalBlock> thrusterList, float percent)
{
thrusterList.ForEach(delegate(IMyTerminalBlock b){
IMyThrust t = (IMyThrust)b;
if (percent < 0) {
t.ThrustOverridePercentage = 0f;
t.Enabled = true;
}else if(percent>0){
t.ThrustOverridePercentage = percent;
t.Enabled = true;
} else {
if(dampenersOn) {
t.ThrustOverridePercentage = 0.0001f;
} else {
t.ThrustOverridePercentage = 0f;
}
t.Enabled = true;
}
});
}

float GetThrusterOverride(IMyThrust thruster)
{
return thruster.GetValue<float>("Override");
}

//Whip's Running Symbol Method v6
int runningSymbolVariant = 0;
string RunningSymbol()
{
runningSymbolVariant++;
string strRunningSymbol = "";

if (runningSymbolVariant == 0)
strRunningSymbol = "|";
else if (runningSymbolVariant == 1)
strRunningSymbol = "/";
else if (runningSymbolVariant == 2)
strRunningSymbol = "--";
else if (runningSymbolVariant == 3)
{
strRunningSymbol = "\\";
runningSymbolVariant = 0;
}

return strRunningSymbol;
}

/*
/// CHANGE LOG ///
v29
...
*/

class AvgQueue{
  const int n = 50;
  double[] q = new double[n];
  int idx = 0;
  double sum = 0;
  public AvgQueue(){
    for (int i = 0; i < n; i++) {
      q[i]=0;
    }
  }

  public double Filter(double a) {
    return a;
    sum -= q[idx];
    sum += a;
    q[idx]=a;
    idx = (idx+1)%n;
    return sum / n;
  }
}

// vtol start
double[] vt_forwardHis = new double[10];
int vt_forwardHisIdx = 0;
float forwardMoveIndicator;
long lastVacTurn = 0;
float vacForwardAngle = 0;
const int pidc= 100;
PIDController[] vtolPIDList = new PIDController[pidc];
float tl = 0f;
AvgQueue needYAvg = new AvgQueue();
AvgQueue needZAvg = new AvgQueue();

bool VT_init = false;
void Main_VT()
{
IMyShipController remote = null;

List<List<IMyTerminalBlock>> rotorLeft = new List<List<IMyTerminalBlock>>(), rotorRight = new List<List<IMyTerminalBlock>>();
//, rotorRear = null;


const string rotorLeftName = "Advanced Rotor Left";
const string rotorRightName = "Advanced Rotor Right";

float targetAngleLeft, targetAngleRight, targetAngleRear;
float leftIndicator, rightIndicator;

string error;
StringBuilder sb = new StringBuilder();
MatrixD inverse;
Vector3D localLinearVelocity, localAngularVelocity;

const float maxAngularVelovityScale = 1;

error = "";

if(remote == null)
{
remote = getBlockByName(CockpitNameTag) as IMyShipController;
}
if(remote == null)
{
error += "no remote control on the same grid.\n";
}

if(rotorLeft.Count == 0)
{
List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyMotorStator>(blocks, x => x.CustomName.Contains(rotorLeftName));
if(blocks.Count > 0)
rotorLeft = sortByRelativePosition(blocks,"X",true);
}
if(rotorLeft.Count == 0)
{
error += $"no rotor with the name {rotorLeftName} on the same grid.\n";
}

if(rotorRight.Count == 0)
{
List<IMyTerminalBlock> blocks = new List<IMyTerminalBlock>();
GridTerminalSystem.GetBlocksOfType<IMyMotorStator>(blocks, x => x.CustomName.Contains(rotorRightName));
if(blocks.Count > 0)
rotorRight = sortByRelativePosition(blocks,"X",false);;
}
if(rotorRight.Count == 0)
{
error += $"no rotor with the name {rotorRightName} on the same grid.\n";
}

if (t<10) {
foreach (var l in rotorLeft) {
PlayActionList(l, "OnOff_Off");
}
foreach (var l in rotorRight) {
PlayActionList(l, "OnOff_Off");
}
return;
}

if (!VT_init) {
foreach (var l in rotorLeft) {
PlayActionList(l, "OnOff_On");
}
foreach (var l in rotorRight) {
PlayActionList(l, "OnOff_On");
}
VT_init=true;
}


// a b k
if (vtolPIDList[0] == null) {
float pp=20F,pi=0F,pd=0F, pim=1F;
for (int i = 0;i < pidc; i ++) {
vtolPIDList[i] = new PIDController(pp, pi, pd,pim,-pim,60);
}
}

if(error != "")
{
return;
}
if(notDocked()){
Vector3D needA = Vector3D.TransformNormal(thrustNeed,refLookAtMatrix) / shipMass; //CODING
 if (Math.Abs(needA.Y) < 0.1 && needA.Length()> 0.1) needA.Y = 0.1;
if (naturalGravityLength < 0.01f && (Math.Abs(needA.Z)<2 || MeVelocity.Length() < 2 )) {
tl = 0; legFoldStart = t;
} else if (t < legFoldStart + legFoldTime && inputVec_RT.Length()<0.1){
tl = 0;
} else if(isApproach) {
tl = (float)Math.PI * dtp;
} else
if (needA.Y >= 0.1 ) // CODING
{
tl = (float)Math.Atan2(needZAvg.Filter(needA.Z), needYAvg.Filter(needA.Y));
}
tl = MathHelper.Clamp(tl, -0.5f*(float)Math.PI, 0.5f*(float)Math.PI);

Vector3D mstm = mySpeedToMe;
if ((naturalGravityLength < 0.01f && tl == 0 && needA.Y < 2)) tl = -(float)Math.PI * 0.5f;
else if (naturalGravityLength > 0.01f && isAeroDynamic &&
(aeroSpeedLevel>0 || (flyByOn&& mstm.Z<-10))
) tl = -(float)Math.PI * 0.45f;

forwardMoveIndicator = tl; // use tl as fmi directly
targetAngleLeft = tl;
targetAngleRight = -tl;
targetAngleRear = 0;
} else {
targetAngleRight = 0;
targetAngleLeft = 0;
targetAngleRear = 0;
}
//add by Kaien notDocked end
for(int i = 0; i < rotorLeft.Count; i++){
List<IMyTerminalBlock> rl = rotorLeft[i], rr = rotorRight[i];
var ta = targetAngleLeft;
if (i>0) {
if (limitInnerRotor) {
// ta = (float)maxTo(ta, 0.4);
}else{
if (legMode == 1) {
if (i == 1) {
ta = MathHelper.Clamp(ta + 0.5f * (float)Math.PI - legMargin, -legMargin, 0.65f*(float)Math.PI - legMargin);
} else {
ta = MathHelper.Clamp(ta - 0.15f*(float)Math.PI + legMargin, legMargin, 0.85f*(float)Math.PI +legMargin);
}
} else if (legMode == 2) {
if (i==1) {
ta = MathHelper.Clamp(ta, -0.25f*(float)Math.PI, 0.1f*(float)Math.PI);
} else {
if (ta > 0.1f*(float)Math.PI) {
ta = MathHelper.Clamp(ta + 0.9f * (float)Math.PI, 0f, 1.4f*(float)Math.PI);
} else if (ta < -0.25f*(float)Math.PI) {
ta = MathHelper.Clamp(ta + 1.25f * (float)Math.PI, 0.75f*(float)Math.PI, 1f*(float)Math.PI);
} else {
ta = (float)Math.PI;
}
}
}
// skip legMode == 3, will process below
else {
ta = 0.5f * ta + 0.25f*(float)Math.PI;
}
}
}

float tal, tar;
tal = tar = ta;
if (legMode ==3) {
processWalkAngle(out tal, out tar, i);
}
// roll
if (! limitInnerRotor && naturalGravityLength > 0.01f && isAeroDynamic && aeroSpeedLevel>0) {
if(i==0 || i == 1) {
float rolldiff = MathHelper.Clamp(inputRoll * 0.1f, -0.1f*(float)Math.PI, 0.1f*(float)Math.PI);
tal += rolldiff;
tar -= rolldiff;
if (i == 0) {
}
}
}

float unmanlimit=1f;
//if(!Cockpit.IsUnderControl) unmanlimit=0.25f;
for (int j = 0; j < rl.Count; j++) {
var ca = ((IMyMotorStator)rl[j]).Angle;
float fa;
if (i == 2) {
fa =  (float)vtolPIDList[i*j*2].Filter(tal-((IMyMotorStator)rl[j]).Angle, 2)*unmanlimit;
} else {
fa = (float)vtolPIDList[i*j*2].Filter(tal-modangle(((IMyMotorStator)rl[j]).Angle), 2)*unmanlimit;
}
rl[j].SetValueFloat("Velocity", fa);
rr[j].SetValueFloat("Velocity", (float)vtolPIDList[i*j*2+1].Filter(-tar-modangle(((IMyMotorStator)rr[j]).Angle), 2)*unmanlimit);
}
}
}

float modangle(float a) {
if (a > Math.PI) return a - (float)(2*Math.PI);
return a;
}

int walkSeq = 0;
static float mpi = (float)Math.PI;
float wa = 0.0f * (float)Math.PI;
float wab = 0.03f * (float)Math.PI;
float wba = 0.1f * (float)Math.PI;
float wbab = 0.07f * (float)Math.PI;
float wua = 0.18f * (float)Math.PI;
float wmf = 0.0f * mpi;
float bal = 0f;
bool wf = false;
PIDController wbp2 = new PIDController(2F,0.1F,0F,1F,-1F,60);
int walkLastT = 0;
int walkInterval = 15;

void processWalkAngle(out float tal, out float tar, int i) {
if (inputVec.Z < -0.1) wf = true;
else if (inputVec.Z > 0.1) wf = false;

var ng = naturalGravity;
var forward = msc.WorldMatrix.Forward;
var left = msc.WorldMatrix.Left;
var diff = diffGravity(left, ng, forward);
if (walkSeq > 3) {
diff += 0.03;
} else {
diff -= 0.03;
}

var diffZ = diffGravity(forward, ng, -left);
if (walkSeq == 1 || walkSeq == 2 || walkSeq == 4|| walkSeq == 5) {
if(t > walkLastT + walkInterval) {
walkSeq ++;
walkLastT = t;
}
} else {
if (wf && t > walkLastT + walkInterval*2 && Math.Abs(diffZ)<0.05) {
if (walkSeq == 3) walkSeq = 4;
else if(walkSeq ==6) walkSeq = 1;
else walkSeq = 6;
walkLastT = t;
}
if (!wf && t>walkLastT + walkInterval*2) {
walkSeq = 0;
walkLastT = t;
}
}

if (i == 0) {
tal = tar = 0f;
return;
}

if (t > walkLastT + walkInterval * 1) {
if (walkSeq == 3) bal = MathHelper.Clamp((float)wbp2.Filter(-diff, 2), -wbab, wbab);
}

float bau = bal;

if (i == 1) {
tal = tar = 0f;
} else {
tal = tar = (float)Math.PI;
}

if (walkSeq == 0) {

} else if (walkSeq==1||walkSeq==4){
if (i==1) {
tar = -wba;
tal = 0;
}else{
tar = wba+ (float)Math.PI + wmf;
tal = -wab+ (float)Math.PI;
}
} else if (walkSeq == 2 || walkSeq==5) {
if (i==1){
tar = -0;
tal = -wua;
}else{
tar = 0 + (float)Math.PI + wmf;
tal = wa + wua + (float)Math.PI + wmf;
}
} else if (walkSeq == 3 || walkSeq == 6) {
if (i == 1) {
tal = - wba;
tar = - wbab + bau;
} else {
tal = wa + wba + (float)Math.PI;
tar = -wab + wbab - bau + (float)Math.PI;
}
}

if (walkSeq > 3) {
var tmp = tal;
tal = tar;
tar = tmp;
}

}

public class PIDController
{
public static double DEF_SMALL_GRID_P = 31.42;
public static double DEF_SMALL_GRID_I = 0;
public static double DEF_SMALL_GRID_D = 10.48;

public static double DEF_BIG_GRID_P = 15.71;
public static double DEF_BIG_GRID_I = 0;
public static double DEF_BIG_GRID_D = 7.05;

double integral;
double lastInput;

double gain_p;
double gain_i;
double gain_d;
double upperLimit_i;
double lowerLimit_i;
double second;

public PIDController(double pGain, double iGain, double dGain, double iUpperLimit = 0, double iLowerLimit = 0, float stepsPerSecond = 60f)
{
gain_p = pGain;
gain_i = iGain;
gain_d = dGain;
upperLimit_i = iUpperLimit;
lowerLimit_i = iLowerLimit;
second = stepsPerSecond;
}

public double Filter(double input, int round_d_digits)
{
double roundedInput = Math.Round(input, round_d_digits);

integral = integral + (input / second);
integral = (upperLimit_i > 0 && integral > upperLimit_i ? upperLimit_i : integral);
integral = (lowerLimit_i < 0 && integral < lowerLimit_i ? lowerLimit_i : integral);

double derivative = (roundedInput - lastInput) * second;
lastInput = roundedInput;

return (gain_p * input) + (gain_i * integral) + (gain_d * derivative);
}

public void Reset()
{
integral = lastInput = 0;
}
}
